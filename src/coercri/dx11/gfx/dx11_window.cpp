/*
 * FILE:
 *   dx11_window.cpp
 *
 * AUTHOR:
 *   Stephen Thompson <stephen@solarflare.org.uk>
 *
 * CREATED:
 *   19-Oct-2011
 *   
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2011.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0, 
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "dx11_gfx_context.hpp"
#include "dx11_window.hpp"
#include "../core/dx_error.hpp"
#include "../../gfx/key_code.hpp"
#include "../../gfx/window_listener.hpp"

#include <cctype>
#include <map>
#include <sstream>

#include <windows.h>
#ifdef MB_RIGHT
#undef MB_RIGHT
#endif

namespace Coercri {

    // This holds errors generated during the window procedure.
    // (We cannot throw exceptions through the Win32 API so we store an error message here,
    // then re-throw it on return from the window procedure.)
    std::string g_win_proc_error_msg;

    namespace {        

        // Global key table
        std::map<int, RawKey> g_vk_to_rk;
        std::map<UINT, RawKey> g_char_to_rk;
        std::map<int, CookedKey> g_vk_to_ck;

        int scancode_left_shift;

        void InitKeyTable()
        {
            if (!g_vk_to_rk.empty()) return;   // Already initialized

            g_vk_to_rk[VK_BACK] = RK_BACKSPACE;
            g_vk_to_rk[VK_CAPITAL] = RK_CAPS_LOCK;
            g_vk_to_rk[VK_CLEAR] = RK_CLEAR;
            g_vk_to_rk[VK_DELETE] = RK_DELETE;
            g_vk_to_rk[VK_DOWN] = RK_DOWN;
            g_vk_to_rk[VK_END] = RK_END;
            g_vk_to_rk[VK_ESCAPE] = RK_ESCAPE;
            g_vk_to_rk[VK_F1] = RK_F1;
            g_vk_to_rk[VK_F2] = RK_F2;
            g_vk_to_rk[VK_F3] = RK_F3;
            g_vk_to_rk[VK_F4] = RK_F4;
            g_vk_to_rk[VK_F5] = RK_F5;
            g_vk_to_rk[VK_F6] = RK_F6;
            g_vk_to_rk[VK_F7] = RK_F7;
            g_vk_to_rk[VK_F8] = RK_F8;
            g_vk_to_rk[VK_F9] = RK_F9;
            g_vk_to_rk[VK_F10] = RK_F10;
            g_vk_to_rk[VK_F11] = RK_F11;
            g_vk_to_rk[VK_F12] = RK_F12;
            g_vk_to_rk[VK_F13] = RK_F13;
            g_vk_to_rk[VK_F14] = RK_F14;
            g_vk_to_rk[VK_F15] = RK_F15;
            g_vk_to_rk[VK_HELP] = RK_HELP;
            g_vk_to_rk[VK_HOME] = RK_HOME;
            g_vk_to_rk[VK_INSERT] = RK_INSERT;
            g_vk_to_rk[VK_NUMPAD0] = RK_KP_0;
            g_vk_to_rk[VK_NUMPAD1] = RK_KP_1;
            g_vk_to_rk[VK_NUMPAD2] = RK_KP_2;
            g_vk_to_rk[VK_NUMPAD3] = RK_KP_3;
            g_vk_to_rk[VK_NUMPAD4] = RK_KP_4;
            g_vk_to_rk[VK_NUMPAD5] = RK_KP_5;
            g_vk_to_rk[VK_NUMPAD6] = RK_KP_6;
            g_vk_to_rk[VK_NUMPAD7] = RK_KP_7;
            g_vk_to_rk[VK_NUMPAD8] = RK_KP_8;
            g_vk_to_rk[VK_NUMPAD9] = RK_KP_9;
            g_vk_to_rk[VK_DIVIDE] = RK_KP_DIVIDE;
            g_vk_to_rk[VK_SUBTRACT] = RK_KP_MINUS;
            g_vk_to_rk[VK_MULTIPLY] = RK_KP_MULTIPLY;
            g_vk_to_rk[VK_DECIMAL] = RK_KP_PERIOD;
            g_vk_to_rk[VK_ADD] = RK_KP_PLUS;
            g_vk_to_rk[VK_LEFT] = RK_LEFT;
            g_vk_to_rk[VK_LMENU] = RK_LEFT_ALT;
            g_vk_to_rk[VK_LCONTROL] = RK_LEFT_CONTROL;
            g_vk_to_rk[VK_LSHIFT] = RK_LEFT_SHIFT;
            g_vk_to_rk[VK_LWIN] = RK_LEFT_WINDOWS;
            g_vk_to_rk[VK_APPS] = RK_MENU;
            g_vk_to_rk[VK_MODECHANGE] = RK_MODE;
            g_vk_to_rk[VK_NUMLOCK] = RK_NUM_LOCK;
            g_vk_to_rk[VK_NEXT] = RK_PAGE_DOWN;
            g_vk_to_rk[VK_PRIOR] = RK_PAGE_UP;
            g_vk_to_rk[VK_PAUSE] = RK_PAUSE;
            g_vk_to_rk[VK_SNAPSHOT] = RK_PRINT_SCREEN;
            g_vk_to_rk[VK_RIGHT] = RK_RIGHT;
            g_vk_to_rk[VK_RMENU] = RK_RIGHT_ALT;
            g_vk_to_rk[VK_RCONTROL] = RK_RIGHT_CONTROL;
            g_vk_to_rk[VK_RSHIFT] = RK_RIGHT_SHIFT;
            g_vk_to_rk[VK_RWIN] = RK_RIGHT_WINDOWS;
            g_vk_to_rk[VK_SCROLL] = RK_SCROLL_LOCK;
            g_vk_to_rk[VK_TAB] = RK_TAB;
            g_vk_to_rk[VK_UP] = RK_UP;
            
            g_char_to_rk['0'] = RK_0;
            g_char_to_rk['1'] = RK_1;
            g_char_to_rk['2'] = RK_2;
            g_char_to_rk['3'] = RK_3;
            g_char_to_rk['4'] = RK_4;
            g_char_to_rk['5'] = RK_5;
            g_char_to_rk['6'] = RK_6;
            g_char_to_rk['7'] = RK_7;
            g_char_to_rk['8'] = RK_8;
            g_char_to_rk['9'] = RK_9;
            g_char_to_rk['a'] = RK_A;
            g_char_to_rk['&'] = RK_AMPERSAND;
            g_char_to_rk['*'] = RK_ASTERISK;
            g_char_to_rk['@'] = RK_AT;
            g_char_to_rk['b'] = RK_B;
            g_char_to_rk['`'] = RK_BACKQUOTE;
            g_char_to_rk['\\'] = RK_BACKSLASH;
            g_char_to_rk['c'] = RK_C;
            g_char_to_rk['^'] = RK_CARET;
            g_char_to_rk[':'] = RK_COLON;
            g_char_to_rk[','] = RK_COMMA;
            g_char_to_rk['d'] = RK_D;
            g_char_to_rk['$'] = RK_DOLLAR;
            g_char_to_rk['"'] = RK_DOUBLE_QUOTE;
            g_char_to_rk['e'] = RK_E;
            g_char_to_rk['='] = RK_EQUALS;
            g_char_to_rk['!'] = RK_EXCLAIM;
            g_char_to_rk['f'] = RK_F;
            g_char_to_rk['g'] = RK_G;
            g_char_to_rk['>'] = RK_GREATER;
            g_char_to_rk['h'] = RK_H;
            g_char_to_rk['#'] = RK_HASH;
            g_char_to_rk['i'] = RK_I;
            g_char_to_rk['j'] = RK_J;
            g_char_to_rk['k'] = RK_K;
            g_char_to_rk['l'] = RK_L;
            g_char_to_rk['['] = RK_LEFT_BRACKET;
            g_char_to_rk['('] = RK_LEFT_PAREN;
            g_char_to_rk['<'] = RK_LESS;
            g_char_to_rk['m'] = RK_M;
            g_char_to_rk['-'] = RK_MINUS;
            g_char_to_rk['n'] = RK_N;
            g_char_to_rk['o'] = RK_O;
            g_char_to_rk['p'] = RK_P;
            g_char_to_rk['.'] = RK_PERIOD;
            g_char_to_rk['+'] = RK_PLUS;
            g_char_to_rk['q'] = RK_Q;
            g_char_to_rk['?'] = RK_QUESTION;
            g_char_to_rk['r'] = RK_R;
            g_char_to_rk[']'] = RK_RIGHT_BRACKET;
            g_char_to_rk[')'] = RK_RIGHT_PAREN;
            g_char_to_rk['s'] = RK_S;
            g_char_to_rk[';'] = RK_SEMICOLON;
            g_char_to_rk['\''] = RK_SINGLE_QUOTE;
            g_char_to_rk['/'] = RK_SLASH;
            g_char_to_rk[' '] = RK_SPACE;
            g_char_to_rk['t'] = RK_T;
            g_char_to_rk['u'] = RK_U;
            g_char_to_rk['_'] = RK_UNDERSCORE;
            g_char_to_rk['v'] = RK_V;
            g_char_to_rk['w'] = RK_W;
            g_char_to_rk['x'] = RK_X;
            g_char_to_rk['y'] = RK_Y;
            g_char_to_rk['z'] = RK_Z;

            g_vk_to_ck[VK_BACK] = CK_BACKSPACE;
            g_vk_to_ck[VK_DELETE] = CK_DELETE;
            g_vk_to_ck[VK_DOWN] = CK_DOWN;
            g_vk_to_ck[VK_END] = CK_END;
            g_vk_to_ck[VK_ESCAPE] = CK_ESCAPE;
            g_vk_to_ck[VK_F1] = CK_F1;
            g_vk_to_ck[VK_F2] = CK_F2;
            g_vk_to_ck[VK_F3] = CK_F3;
            g_vk_to_ck[VK_F4] = CK_F4;
            g_vk_to_ck[VK_F5] = CK_F5;
            g_vk_to_ck[VK_F6] = CK_F6;
            g_vk_to_ck[VK_F7] = CK_F7;
            g_vk_to_ck[VK_F8] = CK_F8;
            g_vk_to_ck[VK_F9] = CK_F9;
            g_vk_to_ck[VK_F10] = CK_F10;
            g_vk_to_ck[VK_F11] = CK_F11;
            g_vk_to_ck[VK_F12] = CK_F12;
            g_vk_to_ck[VK_F13] = CK_F13;
            g_vk_to_ck[VK_F14] = CK_F14;
            g_vk_to_ck[VK_F15] = CK_F15;
            g_vk_to_ck[VK_HELP] = CK_HELP;
            g_vk_to_ck[VK_HOME] = CK_HOME;
            g_vk_to_ck[VK_INSERT] = CK_INSERT;
            g_vk_to_ck[VK_LEFT] = CK_LEFT;
            g_vk_to_ck[VK_LWIN] = CK_LEFT_WINDOWS;
            g_vk_to_ck[VK_APPS] = CK_MENU;
            g_vk_to_ck[VK_MODECHANGE] = CK_MODE;
            g_vk_to_ck[VK_NEXT] = CK_PAGE_DOWN;
            g_vk_to_ck[VK_PRIOR] = CK_PAGE_UP;
            g_vk_to_ck[VK_PAUSE] = CK_PAUSE;
            g_vk_to_ck[VK_SNAPSHOT] = CK_PRINT_SCREEN;
            g_vk_to_ck[VK_RETURN] = CK_RETURN;  // this will catch keypad enter as well
            g_vk_to_ck[VK_RIGHT] = CK_RIGHT;
            g_vk_to_ck[VK_RWIN] = CK_RIGHT_WINDOWS;
            g_vk_to_ck[VK_TAB] = CK_TAB;
            g_vk_to_ck[VK_UP] = CK_UP;

            // store the scancode corresponding to left shift, this will allow
            // us to disambiguate left vs right shift below.
            scancode_left_shift = MapVirtualKey(VK_LSHIFT, MAPVK_VK_TO_VSC);
        }

        // Global state of modifier keys.
        bool g_shift = false;
        bool g_control = false;
        bool g_alt = false;

        KeyModifier CurrentKeyModifiers()
        {
            unsigned int mod = 0;
            if (g_alt) mod |= KM_ALT;
            if (g_control) mod |= KM_CONTROL;
            if (g_shift) mod |= KM_SHIFT;
            return KeyModifier(mod);
        }

        
        // Global window class table
        // (we need to create one window class for each icon used)
        std::map<int, std::string> g_icon_id_to_window_class;

        typedef LRESULT (CALLBACK *WindowProcedure)(HWND, UINT, WPARAM, LPARAM);

        std::string RegisterWindowClass(int icon_id, WindowProcedure wndProc)
        {
            std::map<int, std::string>::const_iterator it = g_icon_id_to_window_class.find(icon_id);
            if (it == g_icon_id_to_window_class.end()) {

                std::ostringstream str;
                str << "CoercriWindowClass";
                str << icon_id;
            
                std::string class_name = str.str();

                // Find the icon resource (if applicable)
                HICON hicon = 0;
                if (icon_id != -1) {
                    const HINSTANCE handle = GetModuleHandle(0);
                    hicon = LoadIcon(handle, MAKEINTRESOURCE(icon_id));
                }

                // Register a new class
                WNDCLASS wc;
                wc.style = CS_HREDRAW | CS_VREDRAW;  // redraw if window size changes
                wc.lpfnWndProc = wndProc;
                wc.cbClsExtra = 0;
                wc.cbWndExtra = 0;
                wc.hInstance = GetModuleHandle(0);
                wc.hIcon = hicon;
                wc.hCursor = LoadCursor(0, IDC_ARROW);
                wc.hbrBackground = HBRUSH(COLOR_WINDOW + 1);
                wc.lpszMenuName = 0;
                wc.lpszClassName = class_name.c_str();

                if (!RegisterClass(&wc)) {
                    throw DXError("Failed to register window class",
                                  HRESULT_FROM_WIN32(GetLastError()));
                }

                it = g_icon_id_to_window_class.insert(std::make_pair(icon_id, class_name)).first;
            }

            return it->second;
        }

        // Global mapping of HWND to DX11Window*
        std::map<HWND, DX11Window*> g_window_table;

        // this may throw an exception (e.g. for messages processed before CreateWindow returns)
        DX11Window & FindWindow(HWND hwnd)
        {
            std::map<HWND, DX11Window*>::const_iterator find_result = g_window_table.find(hwnd);
            if (find_result == g_window_table.end()) {
                throw CoercriError("Window does not exist!");
            } else {
                return *find_result->second;
            }
        }

        // Global show-cursor flag
        bool g_cursor_shown = true;

    }      // end of anonymous namespace


    //
    // Construction and destruction
    //
    
    DX11Window::DX11Window(int width, int height, bool resizable, bool fullscreen, const std::string &title, int icon_id,
                           DX11GfxDriver &gfx_driver_)
        : gfx_driver(gfx_driver_), hwnd(0), 
          inhibit_back_buffer_resize(false), is_minimized(false)
    {
        // Make sure the window procedure is ready to run
        InitKeyTable();

        // Register the window class if required
        const std::string class_name = RegisterWindowClass(icon_id, &windowProc);
        
        // Create the window
        RECT rc;
        SetRect(&rc, 0, 0, width, height);
        AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, false);

        DWORD styles = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
        if (resizable) styles |= WS_THICKFRAME | WS_MAXIMIZEBOX;
        
        hwnd = CreateWindow(class_name.c_str(),
                            title.c_str(),
                            styles,
                            CW_USEDEFAULT,  // or x
                            CW_USEDEFAULT,  // or y
                            (rc.right - rc.left),
                            (rc.bottom - rc.top),
                            0,    // no parent window
                            0,    // no menu
                            GetModuleHandle(0),
                            0);   // no parameter to WM_CREATE message
        if (!hwnd) {
            throw DXError("Failed to create window",
                          HRESULT_FROM_WIN32(GetLastError()));
        }

        // We need to ensure that hwnd gets destroyed if there is an exception
        try {

            // Make an association between that hwnd and this DX11Window object
            // (for window proc to use)
            g_window_table.insert(std::make_pair(hwnd, this));
            
            // Grab the DXGI factory
            IDXGIFactory *pFactory = gfx_driver.getDXGIFactory();
            
            // Create the windowed swap chain
            DXGI_SWAP_CHAIN_DESC sd;
            sd.BufferDesc.Width = width;
            sd.BufferDesc.Height = height;
            sd.BufferDesc.RefreshRate.Numerator = 0;  // ignored for windowed mode (http://forums.create.msdn.com/forums/t/2353.aspx)
            sd.BufferDesc.RefreshRate.Denominator = 0;  // ignored for windowed mode
            sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;  // our preferred pixel format
            sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;  // ignored for windowed mode
            sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;  // ignored for windowed mode
            sd.SampleDesc.Count = 1;   // no antialiasing
            sd.SampleDesc.Quality = 0; // no antialiasing
            sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
            sd.BufferCount = 1;
            sd.OutputWindow = hwnd;
            sd.Windowed = true;
            sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
            sd.Flags = 0;
            
            IDXGISwapChain *pSwapChain;
            HRESULT hr = pFactory->CreateSwapChain(gfx_driver.getDevice(), &sd, &pSwapChain);
            if (FAILED(hr)) {
                throw DXError("IDXGIFactory::CreateSwapChain failed", hr);
            }
            m_psSwapChain.reset(pSwapChain);
            
            // Show the window -- this will also generate a WM_SIZE event,
            // which will do the initial call to handleWindowResize().
            ShowWindow(hwnd, SW_SHOWNORMAL);
            
            // Go into fullscreen mode if requested
            // (Note width, height are ignored in the current
            // implementation, and it just uses the desktop mode)
            if (fullscreen) {
                switchToFullScreen(width, height);
            }

        } catch (...) {
            cleanUpWindow();
            throw;
        }
    }

    void DX11Window::createRenderTargetView()
    {
        ID3D11Texture2D * pBackBuffer = 0;
        HRESULT hr = m_psSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(&pBackBuffer));
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::GetBuffer failed", hr);
        }
        ComPtrWrapper<ID3D11Texture2D> psBackBuffer(pBackBuffer);
        
        ID3D11RenderTargetView *rtv;
        hr = gfx_driver.getDevice()->CreateRenderTargetView(pBackBuffer,
                                                            0,
                                                            &rtv);
        if (FAILED(hr)) {
            throw DXError("ID3D11Device::CreateRenderTargetView failed", hr);
        }
        m_psRenderTargetView.reset(rtv);
    }

    DX11Window::~DX11Window()
    {
        cleanUpWindow();
    }

    void DX11Window::cleanUpWindow()
    {
        // This runs from within destructor, so should not throw

        // It is not allowed to destroy a swap chain that is in fullscreen mode (see MSDN).
        // So set to windowed mode first.
        if (m_psSwapChain.get()) {
            // The following call to SetFullscreenState fires off a WM_SIZE event which
            // in turn causes the swap chain / back buffer to be resized.
            // For some reason this causes warning messages from DX11 about objects not
            // being cleaned up properly.
            // The fix is to inhibit the back buffer resizing -- it is not needed anyway
            // since we are about to destroy the window...
            inhibit_back_buffer_resize = true;
            m_psSwapChain->SetFullscreenState(false, 0);
        }

        DestroyWindow(hwnd);
        g_window_table.erase(hwnd);
    }


    //
    // "Get" type methods
    //

    void DX11Window::getSize(int &w, int &h) const
    {
        DXGI_SWAP_CHAIN_DESC sd;

        // const_cast needed because IDXGISwapChain::GetDesc declaration
        // is not (IMO) const correct
        HRESULT hr = const_cast<IDXGISwapChain&>(*m_psSwapChain).GetDesc(&sd);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::GetDesc failed", hr);
        }

        w = sd.BufferDesc.Width;
        h = sd.BufferDesc.Height;
    }

    bool DX11Window::hasFocus() const
    {
        return (GetActiveWindow() == hwnd);
    }

    bool DX11Window::isFullScreen() const
    {
        BOOL is_full_screen;
        IDXGIOutput *dummy;

        HRESULT hr = const_cast<IDXGISwapChain&>(*m_psSwapChain).GetFullscreenState(&is_full_screen, &dummy);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::GetFullscreenState failed", hr);
        } else if (dummy) {
            dummy->Release();
        }

        return is_full_screen != 0;
    }
    

    //
    // Window popup
    //
    
    void DX11Window::popToFront()
    {
        // Restore it if it was minimized
        if (IsIconic(hwnd)) {
            ShowWindow(hwnd, SW_RESTORE);
        }

        // Focus the window / bring it to the front (if possible)
        SetForegroundWindow(hwnd);
    }

    
    //
    // Mouse pointer control
    //
    
    void DX11Window::showMousePointer(bool shown)
    {
        if (g_cursor_shown != shown) {
            ShowCursor(shown);
            g_cursor_shown = shown;
        }
    }

    void DX11Window::captureMouse(bool captured)
    {
        if (captured) {
            SetCapture(hwnd);
        } else {
            ReleaseCapture();
        }
    }
    
    
    //
    // Fullscreen / windowed switching
    //

    void DX11Window::switchToWindowed(int w, int h)
    {
        // Put it into windowed mode first
        HRESULT hr = m_psSwapChain->SetFullscreenState(false, 0);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::SetFullscreenState failed", hr);
        }

        // Now resize to the desired size
        DXGI_MODE_DESC mode;
        mode.Width = w;
        mode.Height = h;
        mode.RefreshRate.Numerator = 0; // ignored for windowed mode
        mode.RefreshRate.Denominator = 0; // ignored
        mode.Format = DXGI_FORMAT_R8G8B8A8_UNORM;    // our preferred pixel format
        mode.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;  // ignored
        mode.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;  // ignored

        hr = m_psSwapChain->ResizeTarget(&mode);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::ResizeTarget failed", hr);
        }
    }
        
    void DX11Window::switchToFullScreen(int w, int h)
    {
        // Go into full screen mode
        //
        // Note: The w, h parameters are for the caller to set the
        // display mode. However, I had some difficulty getting this
        // to work with DX11, so currently I just ignore the w, h
        // parameters and just use the desktop mode. None of my
        // programs currently require a custom display mode so this
        // should be ok for now.
        
        IDXGIOutput * pOutput = gfx_driver.getPrimaryOutput();
        HRESULT hr = m_psSwapChain->SetFullscreenState(true, pOutput);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::SetFullscreenState failed", hr);
        }
    }
    

    //
    // Gfx context handling
    //

    std::auto_ptr<GfxContext> DX11Window::createGfxContext()
    {
        // note: only one GfxContext should be created at a time.
        // this is enforced by PrimitiveBatch.
        std::auto_ptr<GfxContext> gc(new DX11GfxContext(gfx_driver.getDeviceContext(),
                                                        m_psRenderTargetView.get(),
                                                        m_psSwapChain.get(),
                                                        gfx_driver.getPrimitiveBatch()));
        return gc;
    }



    //
    // Private methods
    //

    // The window procedure
    LRESULT CALLBACK DX11Window::windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
    {
        // we don't want exceptions propagating through into Win32 API
        // so enclose this fn in a try/catch block
        try {
        
            typedef std::vector<WindowListener*> wl_vec;
            typedef wl_vec::const_iterator iter;
            
            // Process the message.
            // If there are any callbacks, we call them directly from this WndProc
            switch (msg) {

            case WM_SETFOCUS:
                {
                    // Window has gained input focus
                    const wl_vec listeners = FindWindow(hwnd).getListeners();
                    for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                        (*it)->onGainFocus();
                    }
                }
                break;

            case WM_KILLFOCUS:
                {
                    // Window has lost input focus
                    const wl_vec listeners = FindWindow(hwnd).getListeners();
                    for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                        (*it)->onLoseFocus();
                    }
                
                    // Reset modifier state when window is deselected
                    // (as we won't necessarily get the KEYDOWN messages).
                    g_alt = g_control = g_shift = false;
                }
                break;
            
            case WM_CLOSE:
                {
                    // Notify listeners that the window has been destroyed
                    DX11Window &window = FindWindow(hwnd);
                    const wl_vec &listeners = window.getListeners();
                    for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                        (*it)->onClose();
                    }

                    // Return 0 to prevent DefWindowProc from destroying the window immediately
                    return 0;
                }
                break;
            
            case WM_PAINT:
                // Note: because we are using
                // DXGI_SWAP_EFFECT_DISCARD, we must invalidate the
                // entire window, not just Windows's "update
                // rectangle".
                FindWindow(hwnd).invalidateAll();
                break;
                
            case WM_SIZE:
                {
                    DX11Window &window = FindWindow(hwnd);
                    const wl_vec &listeners = window.getListeners();
                    
                    // resize the back-buffer if necessary
                    if (!window.inhibit_back_buffer_resize) {
                        window.handleWindowResize();
                    }

                    // send the onActivate / onDeactivate msgs on maximization / restore.
                    if (wparam == SIZE_MINIMIZED) {
                        if (!window.is_minimized) {
                            for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                                (*it)->onDeactivate();
                            }
                            window.is_minimized = true;
                        }
                    } else {
                        if (window.is_minimized) {
                            for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                                (*it)->onActivate();
                            }
                            window.is_minimized = false;
                        }
                    }
                }
                break;

            case WM_ENTERSIZEMOVE:
                // Prevent back buffer resizing while user is dragging/resizing the window.
                FindWindow(hwnd).inhibit_back_buffer_resize = true;
                break;

            case WM_EXITSIZEMOVE:
                {
                    DX11Window& window = FindWindow(hwnd);
                    window.inhibit_back_buffer_resize = false;
                    window.handleWindowResize();
                }
                break;
                
            case WM_SYSKEYDOWN:
            case WM_KEYDOWN:
            case WM_SYSKEYUP:
            case WM_KEYUP:
                {
                    DX11Window &window = FindWindow(hwnd);
                    const wl_vec &listeners = window.getListeners();

                    // lparam holds a few flags; decode the ones we are interested in.
                    const bool extended   = (lparam & 0x01000000) != 0;
                    const bool prev_state = (lparam & 0x40000000) != 0;  // true if key was previously down
                    const bool new_state  = (msg == WM_SYSKEYDOWN || msg == WM_KEYDOWN);   // true if key is now down
                    const int scancode = (lparam & 0x00FF0000) >> 16;
                    
                    // wparam holds the windows virtual key code.
                    // convert this to a coercri RawKey.
                    // also update our global modifier flags if required.
                    
                    RawKey rk = RK_UNKNOWN;
                    
                    if (wparam == VK_RETURN) {
                        rk = extended ? RK_KP_ENTER : RK_RETURN;
                        
                    } else if (wparam == VK_MENU) {   // alt
                        rk = extended ? RK_RIGHT_ALT : RK_LEFT_ALT;
                        g_alt = new_state;
                            
                    } else if (wparam == VK_CONTROL) {
                        rk = extended ? RK_RIGHT_CONTROL : RK_LEFT_CONTROL;
                        g_control = new_state;

                    } else if (wparam == VK_SHIFT) {
                        // "extended" flag does not apply to shift, so
                        // we have to check the scancodes
                        if (scancode == scancode_left_shift) {
                            rk = RK_LEFT_SHIFT;
                        } else {
                            rk = RK_RIGHT_SHIFT;
                        }
                        g_shift = new_state;

                    } else {
                        // Try looking up in g_vk_to_rk
                        const std::map<int, RawKey>::const_iterator it = g_vk_to_rk.find(wparam);
                        if (it != g_vk_to_rk.end()) {
                            // Found it
                            rk = it->second;
                            
                        } else {
                            // Use MapVirtualKey to obtain a Unicode character,
                            // then look this up in g_char_to_rk
                            UINT ch = MapVirtualKey(wparam, MAPVK_VK_TO_CHAR) & 0xffff;
                            if (ch != 0) {
                                UINT new_ch;
                                if (ch <= 0xff) new_ch = std::tolower(ch);
                                else new_ch = ch;
                                const std::map<UINT, RawKey>::const_iterator it2 = g_char_to_rk.find(new_ch);
                                if (it2 != g_char_to_rk.end()) {
                                    // Found it
                                    rk = it2->second;
                                }
                            }
                        }
                    }

                    // Okay, now we have enough info to send a RawKey message
                    // NOTE: Filter out key repeat events
                    if (new_state != prev_state && rk != RK_UNKNOWN) {
                        for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                            (*it)->onRawKey(new_state, rk);
                        }
                    }

                    // Now for cooked key events. These only occur for keydown (i.e. new_state == true),
                    // but repeats are allowed this time.
                    if (new_state) {
                        const std::map<int, CookedKey>::const_iterator it = g_vk_to_ck.find(wparam);
                        if (it != g_vk_to_ck.end()) {
                            const CookedKey ck = it->second;
                            const KeyModifier mod = CurrentKeyModifiers();
                            for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                                (*it)->onCookedKey(ck, 0, mod);
                            }
                        }
                    }
                }
                break;

            case WM_CHAR:
                {
                    DX11Window &window = FindWindow(hwnd);
                    const wl_vec &listeners = window.getListeners();

                    // wparam contains the Unicode character code.
                    // 
                    // (Technically this is UTF-16, rather than straight
                    // Unicode, so 'extraplanar' characters will come out
                    // as surrogate pairs rather than single code points.
                    // This is acceptable for now though.)

                    // We filter out unwanted control characters: 0 to 31 and 127.
                    // (This could probably be made more robust using
                    // some Unicode "is printable" function.)
                    if (wparam >= 32 && wparam != 127) {
                        const KeyModifier mods = CurrentKeyModifiers();
                        for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                            (*it)->onCookedKey(CK_CHARACTER, wparam, mods);
                        }
                    }
                }
                break;

            case WM_MOUSEMOVE:
                {
                    DX11Window &window = FindWindow(hwnd);
                    const wl_vec &listeners = window.getListeners();

                    const int x = (int)(short int)(LOWORD(lparam));
                    const int y = (int)(short int)(HIWORD(lparam));
                    for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                        (*it)->onMouseMove(x, y);
                    }
                }
                break;

            case WM_LBUTTONDOWN:   // lparam = coordinates
            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
                {
                    DX11Window &window = FindWindow(hwnd);
                    const wl_vec &listeners = window.getListeners();

                    const int x = LOWORD(lparam);
                    const int y = HIWORD(lparam);
                    MouseButton mb;
                    if (msg == WM_LBUTTONDOWN) mb = MB_LEFT;
                    else if (msg == WM_RBUTTONDOWN) mb = MB_RIGHT;
                    else mb = MB_MIDDLE;
                    for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                        (*it)->onMouseDown(x, y, mb);
                    }
                }
                break;

            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_MBUTTONUP:
                {
                    DX11Window &window = FindWindow(hwnd);
                    const wl_vec &listeners = window.getListeners();

                    const int x = LOWORD(lparam);
                    const int y = HIWORD(lparam);
                    MouseButton mb;
                    if (msg == WM_LBUTTONUP) mb = MB_LEFT;
                    else if (msg == WM_RBUTTONUP) mb = MB_RIGHT;
                    else mb = MB_MIDDLE;
                    for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                        (*it)->onMouseUp(x, y, mb);
                    }
                }
                break;

            case WM_MOUSEWHEEL:
                {
                    DX11Window &window = FindWindow(hwnd);
                    const wl_vec &listeners = window.getListeners();

                    const int x = LOWORD(lparam);
                    const int y = HIWORD(lparam);
                    short int motion = ((short int)HIWORD(wparam)) / (short int)WHEEL_DELTA;
                    MouseButton mb;
                    if (motion < 0) {
                        mb = MB_WHEEL_DOWN;
                        motion = -motion;
                    } else {
                        mb = MB_WHEEL_UP;
                    }
                    for (short int i = 0; i < motion; ++i) {
                        for (iter it = listeners.begin(); it != listeners.end(); ++it) {
                            (*it)->onMouseDown(x, y, mb);
                        }
                        for (iter it = listeners.begin(); it != listeners.end(); ++it) {                    
                            (*it)->onMouseUp(x, y, mb);
                        }
                    }
                }
                break;

            case WM_SYSCOMMAND:
                // Disable the ALT and F10 keys
                if (wparam == SC_KEYMENU) return 0;
                break;
            }

            return DefWindowProc(hwnd, msg, wparam, lparam);

        } catch (std::exception &e) {
            g_win_proc_error_msg = e.what();
            return -1;

        } catch (...) {
            // Unknown exception, we can't do anything with it
            return -1;
        }
    }

    void DX11Window::handleWindowResize()
    {
        // Find the current window size
        RECT rect;
        if (!GetClientRect(hwnd, &rect)) {
            throw DXError("GetClientRect failed", HRESULT_FROM_WIN32(GetLastError()));
        }
        const int width = rect.right;
        const int height = rect.bottom;
        
        if (m_psSwapChain.get()) {

            // We have to release the render target view, resize the
            // swap chain, then recreate the render target view.
            m_psRenderTargetView.reset(0);
            
            HRESULT hr = m_psSwapChain->ResizeBuffers(0,   // preserve existing number of buffers
                                                      width,
                                                      height,
                                                      DXGI_FORMAT_UNKNOWN,   // preserve current format
                                                      0);   // do not allow display mode changes
            if (FAILED(hr)) {
                throw DXError("IDXGISwapChain::ResizeBuffers failed", hr);
            }

            createRenderTargetView();
        }

        // Call any Coercri resize-listeners
        for (std::vector<WindowListener*>::iterator it = listeners.begin(); it != listeners.end(); ++it) {
            (*it)->onResize(width, height);
        }

        // Invalidate the whole window after a resize (forces everything to repaint).
        invalid_region.clear();
        invalid_region.addRectangle(Rectangle(0,0,width,height));
    }
}
