/*
 * FILE:
 *   dx11_window.cpp
 *
 * AUTHOR:
 *   Stephen Thompson <stephen@solarflare.org.uk>
 *
 * CREATED:
 *   19-Oct-2011
 *   
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2011.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0, 
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "dx11_gfx_context.hpp"
#include "dx11_window.hpp"
#include "../core/dx_error.hpp"
#include "../../gfx/key_code.hpp"
#include "../../gfx/window_listener_funcs.hpp"

#include <cctype>
#include <map>
#include <sstream>

#include <windowsx.h>
#ifdef MB_RIGHT
#undef MB_RIGHT
#endif
#ifdef FindWindow
#undef FindWindow
#endif

namespace Coercri {

    // Event queueing.
    
    
    // This holds errors generated during the window procedure.
    // (We cannot throw exceptions through the Win32 API so we store an error message here,
    // then re-throw it on return from the window procedure.)
    std::string g_win_proc_error_msg;

    namespace {        

        int scancode_left_shift;

        KeyCode VK_to_KC(int vk)
        {
            switch (vk) {
            case VK_BACK: return KC_BACKSPACE;
            case VK_CAPITAL: return KC_CAPS_LOCK;
            case VK_CLEAR: return KC_CLEAR;
            case VK_DELETE: return KC_DELETE;
            case VK_DOWN: return KC_DOWN;
            case VK_END: return KC_END;
            case VK_ESCAPE: return KC_ESCAPE;
            case VK_F1: return KC_F1;
            case VK_F2: return KC_F2;
            case VK_F3: return KC_F3;
            case VK_F4: return KC_F4;
            case VK_F5: return KC_F5;
            case VK_F6: return KC_F6;
            case VK_F7: return KC_F7;
            case VK_F8: return KC_F8;
            case VK_F9: return KC_F9;
            case VK_F10: return KC_F10;
            case VK_F11: return KC_F11;
            case VK_F12: return KC_F12;
            case VK_F13: return KC_F13;
            case VK_F14: return KC_F14;
            case VK_F15: return KC_F15;
            case VK_HELP: return KC_HELP;
            case VK_HOME: return KC_HOME;
            case VK_INSERT: return KC_INSERT;
            case VK_NUMPAD0: return KC_KP_0;
            case VK_NUMPAD1: return KC_KP_1;
            case VK_NUMPAD2: return KC_KP_2;
            case VK_NUMPAD3: return KC_KP_3;
            case VK_NUMPAD4: return KC_KP_4;
            case VK_NUMPAD5: return KC_KP_5;
            case VK_NUMPAD6: return KC_KP_6;
            case VK_NUMPAD7: return KC_KP_7;
            case VK_NUMPAD8: return KC_KP_8;
            case VK_NUMPAD9: return KC_KP_9;
            case VK_DIVIDE: return KC_KP_DIVIDE;
            case VK_SUBTRACT: return KC_KP_MINUS;
            case VK_MULTIPLY: return KC_KP_MULTIPLY;
            case VK_DECIMAL: return KC_KP_PERIOD;
            case VK_ADD: return KC_KP_PLUS;
            case VK_LEFT: return KC_LEFT;
            case VK_LMENU: return KC_LEFT_ALT;
            case VK_LCONTROL: return KC_LEFT_CONTROL;
            case VK_LSHIFT: return KC_LEFT_SHIFT;
            case VK_LWIN: return KC_LEFT_WINDOWS;
            case VK_APPS: return KC_MENU;
            case VK_MODECHANGE: return KC_MODE;
            case VK_NUMLOCK: return KC_NUM_LOCK;
            case VK_NEXT: return KC_PAGE_DOWN;
            case VK_PRIOR: return KC_PAGE_UP;
            case VK_PAUSE: return KC_PAUSE;
            case VK_SNAPSHOT: return KC_PRINT_SCREEN;
            case VK_RIGHT: return KC_RIGHT;
            case VK_RMENU: return KC_RIGHT_ALT;
            case VK_RCONTROL: return KC_RIGHT_CONTROL;
            case VK_RSHIFT: return KC_RIGHT_SHIFT;
            case VK_RWIN: return KC_RIGHT_WINDOWS;
            case VK_SCROLL: return KC_SCROLL_LOCK;
            case VK_TAB: return KC_TAB;
            case VK_UP: return KC_UP;
            default: return KC_UNKNOWN;
            }
        }

        KeyCode Char_to_KC(UINT ch)
        {
            switch (ch) {
            case '0': return KC_0;
            case '1': return KC_1;
            case '2': return KC_2;
            case '3': return KC_3;
            case '4': return KC_4;
            case '5': return KC_5;
            case '6': return KC_6;
            case '7': return KC_7;
            case '8': return KC_8;
            case '9': return KC_9;
            case 'a': return KC_A;
            case '&': return KC_AMPERSAND;
            case '*': return KC_ASTERISK;
            case '@': return KC_AT;
            case 'b': return KC_B;
            case '`': return KC_BACKQUOTE;
            case '\\': return KC_BACKSLASH;
            case 'c': return KC_C;
            case '^': return KC_CARET;
            case ':': return KC_COLON;
            case ',': return KC_COMMA;
            case 'd': return KC_D;
            case '$': return KC_DOLLAR;
            case '"': return KC_DOUBLE_QUOTE;
            case 'e': return KC_E;
            case '=': return KC_EQUALS;
            case '!': return KC_EXCLAIM;
            case 'f': return KC_F;
            case 'g': return KC_G;
            case '>': return KC_GREATER;
            case 'h': return KC_H;
            case '#': return KC_HASH;
            case 'i': return KC_I;
            case 'j': return KC_J;
            case 'k': return KC_K;
            case 'l': return KC_L;
            case '[': return KC_LEFT_BRACKET;
            case '(': return KC_LEFT_PAREN;
            case '<': return KC_LESS;
            case 'm': return KC_M;
            case '-': return KC_MINUS;
            case 'n': return KC_N;
            case 'o': return KC_O;
            case 'p': return KC_P;
            case '%': return KC_PERCENT;
            case '.': return KC_PERIOD;
            case '+': return KC_PLUS;
            case 'q': return KC_Q;
            case '?': return KC_QUESTION;
            case 'r': return KC_R;
            case ']': return KC_RIGHT_BRACKET;
            case ')': return KC_RIGHT_PAREN;
            case 's': return KC_S;
            case ';': return KC_SEMICOLON;
            case '\'': return KC_SINGLE_QUOTE;
            case '/': return KC_SLASH;
            case ' ': return KC_SPACE;
            case 't': return KC_T;
            case 'u': return KC_U;
            case '_': return KC_UNDERSCORE;
            case 'v': return KC_V;
            case 'w': return KC_W;
            case 'x': return KC_X;
            case 'y': return KC_Y;
            case 'z': return KC_Z;
            default: return KC_UNKNOWN;
            }
        }
        
        const wchar_t * COERCRI_WINDOW_CLASS_NAME = L"CoercriWindowClass";

        typedef LRESULT (CALLBACK *WindowProcedure)(HWND, UINT, WPARAM, LPARAM);

        void RegisterWindowClass(WindowProcedure wndProc)
        {
            // this should only be called once.
            static bool window_class_registered = false;
            if (window_class_registered) return;
            window_class_registered = true;

            // Register a new class
            WNDCLASSW wc;
            wc.style = CS_HREDRAW | CS_VREDRAW;  // redraw if window size changes
            wc.lpfnWndProc = wndProc;
            wc.cbClsExtra = 0;
            wc.cbWndExtra = 0;
            wc.hInstance = GetModuleHandle(0);
            wc.hIcon = 0;
            wc.hCursor = LoadCursor(0, IDC_ARROW);
            wc.hbrBackground = HBRUSH(COLOR_WINDOW + 1);
            wc.lpszMenuName = 0;
            wc.lpszClassName = COERCRI_WINDOW_CLASS_NAME;

            if (!RegisterClassW(&wc)) {
                throw DXError("Failed to register window class",
                                HRESULT_FROM_WIN32(GetLastError()));
            }
        }

        // Global mapping of HWND to DX11Window*
        std::map<HWND, DX11Window*> g_window_table;

        // this may throw an exception (e.g. for messages processed before CreateWindow returns)
        DX11Window & FindWindow(HWND hwnd)
        {
            std::map<HWND, DX11Window*>::const_iterator find_result = g_window_table.find(hwnd);
            if (find_result == g_window_table.end()) {
                throw CoercriError("Window does not exist!");
            } else {
                return *find_result->second;
            }
        }

        // Global show-cursor flag
        bool g_cursor_shown = true;

    }      // end of anonymous namespace


    //
    // Construction and destruction
    //
    
    DX11Window::DX11Window(int width, int height,
                           bool resizable, bool fullscreen,
                           const std::string &title,
                           DX11GfxDriver &gfx_driver_)
        : gfx_driver(gfx_driver_), hwnd(0), 
          inhibit_back_buffer_resize(false), is_minimized(false),
          left_shift_state(false), right_shift_state(false),
          left_control_state(false), right_control_state(false),
          left_alt_state(false), right_alt_state(false)
    {
        if (fullscreen) {
            // input width/height are meaningless if fullscreen is true
            // so just set them to some reasonable "dummy" values
            width = 200;
            height = 200;
        }

        // Store the left shift scancode if we haven't already.
        // (This will allow us to disambiguate left vs right shift below)
        scancode_left_shift = MapVirtualKey(VK_LSHIFT, MAPVK_VK_TO_VSC);

        // Register the window class if required
        RegisterWindowClass(&windowProc);
        
        // convert the title to UTF-16 for windows...
        // note: we assume Latin-1 input encoding for now.
        std::wstring wtitle;
        for (std::string::const_iterator it = title.begin(); it != title.end(); ++it) {
            wtitle.push_back(static_cast<unsigned char>(*it));
        }

        // Create the window
        RECT rc;
        SetRect(&rc, 0, 0, width, height);
        AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, false);

        DWORD styles = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
        if (resizable) styles |= WS_THICKFRAME | WS_MAXIMIZEBOX;
        
        hwnd = CreateWindowW(COERCRI_WINDOW_CLASS_NAME,
                             wtitle.c_str(),
                             styles,
                             CW_USEDEFAULT,  // or x
                             CW_USEDEFAULT,  // or y
                             (rc.right - rc.left),
                             (rc.bottom - rc.top),
                             0,    // no parent window
                             0,    // no menu
                             GetModuleHandle(0),
                             0);   // no parameter to WM_CREATE message
        if (!hwnd) {
            throw DXError("Failed to create window",
                          HRESULT_FROM_WIN32(GetLastError()));
        }

        set_icon.reset(new Win32SetIcon(hwnd));

        // We need to ensure that hwnd gets destroyed if there is an exception
        try {

            // Make an association between that hwnd and this DX11Window object
            // (for window proc to use)
            g_window_table.insert(std::make_pair(hwnd, this));
            
            // Grab the DXGI factory
            IDXGIFactory *pFactory = gfx_driver.getDXGIFactory();
            
            // Create the windowed swap chain
            DXGI_SWAP_CHAIN_DESC sd;
            sd.BufferDesc.Width = width;
            sd.BufferDesc.Height = height;
            sd.BufferDesc.RefreshRate.Numerator = 0;  // ignored for windowed mode (http://forums.create.msdn.com/forums/t/2353.aspx)
            sd.BufferDesc.RefreshRate.Denominator = 0;  // ignored for windowed mode
            sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;  // our preferred pixel format
            sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;  // ignored for windowed mode
            sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;  // ignored for windowed mode
            sd.SampleDesc.Count = 1;   // no antialiasing
            sd.SampleDesc.Quality = 0; // no antialiasing
            sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
            sd.BufferCount = 1;
            sd.OutputWindow = hwnd;
            sd.Windowed = true;
            sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
            sd.Flags = 0;
            
            IDXGISwapChain *pSwapChain;
            HRESULT hr = pFactory->CreateSwapChain(gfx_driver.getDevice(), &sd, &pSwapChain);
            if (FAILED(hr)) {
                throw DXError("IDXGIFactory::CreateSwapChain failed", hr);
            }
            m_psSwapChain.reset(pSwapChain);
            
            // Show the window -- this will also generate a WM_SIZE event,
            // which will do the initial call to handleWindowResize().
            ShowWindow(hwnd, SW_SHOWNORMAL);
            
            // Go into fullscreen mode if requested
            if (fullscreen) {
                switchToFullScreen();
            }

        } catch (...) {
            cleanUpWindow();
            throw;
        }
    }

    void DX11Window::createRenderTargetView()
    {
        ID3D11Texture2D * pBackBuffer = 0;
        HRESULT hr = m_psSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(&pBackBuffer));
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::GetBuffer failed", hr);
        }
        ComPtrWrapper<ID3D11Texture2D> psBackBuffer(pBackBuffer);
        
        ID3D11RenderTargetView *rtv;
        hr = gfx_driver.getDevice()->CreateRenderTargetView(pBackBuffer,
                                                            0,
                                                            &rtv);
        if (FAILED(hr)) {
            throw DXError("ID3D11Device::CreateRenderTargetView failed", hr);
        }
        m_psRenderTargetView.reset(rtv);
    }

    DX11Window::~DX11Window()
    {
        cleanUpWindow();
    }

    void DX11Window::cleanUpWindow()
    {
        // This runs from within destructor, so should not throw

        // It is not allowed to destroy a swap chain that is in fullscreen mode (see MSDN).
        // So set to windowed mode first.
        if (m_psSwapChain.get()) {
            // The following call to SetFullscreenState fires off a WM_SIZE event which
            // in turn causes the swap chain / back buffer to be resized.
            // For some reason this causes warning messages from DX11 about objects not
            // being cleaned up properly.
            // The fix is to inhibit the back buffer resizing -- it is not needed anyway
            // since we are about to destroy the window...
            inhibit_back_buffer_resize = true;
            m_psSwapChain->SetFullscreenState(false, 0);
        }

        DestroyWindow(hwnd);
        g_window_table.erase(hwnd);
    }


    //
    // "Get" type methods
    //

    void DX11Window::getSize(int &w, int &h) const
    {
        DXGI_SWAP_CHAIN_DESC sd;

        // const_cast needed because IDXGISwapChain::GetDesc declaration
        // is not (IMO) const correct
        HRESULT hr = const_cast<IDXGISwapChain&>(*m_psSwapChain).GetDesc(&sd);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::GetDesc failed", hr);
        }

        w = sd.BufferDesc.Width;
        h = sd.BufferDesc.Height;
    }

    bool DX11Window::hasFocus() const
    {
        return (GetActiveWindow() == hwnd);
    }

    bool DX11Window::isFullScreen() const
    {
        BOOL is_full_screen;
        IDXGIOutput *dummy;

        HRESULT hr = const_cast<IDXGISwapChain&>(*m_psSwapChain).GetFullscreenState(&is_full_screen, &dummy);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::GetFullscreenState failed", hr);
        } else if (dummy) {
            dummy->Release();
        }

        return is_full_screen != 0;
    }
    
    bool DX11Window::isMaximized() const
    {
        return IsZoomed(hwnd) != 0;
    }

    //
    // Window popup
    //
    
    void DX11Window::popToFront()
    {
        // Restore it if it was minimized
        if (IsIconic(hwnd)) {
            ShowWindow(hwnd, SW_RESTORE);
        }

        // Focus the window / bring it to the front (if possible)
        SetForegroundWindow(hwnd);
    }

    
    //
    // Mouse pointer control
    //
    
    void DX11Window::showMousePointer(bool shown)
    {
        if (g_cursor_shown != shown) {
            ShowCursor(shown);
            g_cursor_shown = shown;
        }
    }

    void DX11Window::captureMouse(bool captured)
    {
        if (captured) {
            SetCapture(hwnd);
        } else {
            ReleaseCapture();
        }
    }
    
    
    //
    // Fullscreen / windowed switching
    //

    void DX11Window::switchToWindowed(int w, int h)
    {
        // Put it into windowed mode first
        HRESULT hr = m_psSwapChain->SetFullscreenState(false, 0);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::SetFullscreenState failed", hr);
        }

        // Now resize to the desired size
        DXGI_MODE_DESC mode;
        mode.Width = w;
        mode.Height = h;
        mode.RefreshRate.Numerator = 0; // ignored for windowed mode
        mode.RefreshRate.Denominator = 0; // ignored
        mode.Format = DXGI_FORMAT_R8G8B8A8_UNORM;    // our preferred pixel format
        mode.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;  // ignored
        mode.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;  // ignored

        hr = m_psSwapChain->ResizeTarget(&mode);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::ResizeTarget failed", hr);
        }
    }
        
    void DX11Window::switchToFullScreen()
    {
        // Go into full screen mode
        
        IDXGIOutput * pOutput = gfx_driver.getPrimaryOutput();
        HRESULT hr = m_psSwapChain->SetFullscreenState(true, pOutput);
        if (FAILED(hr)) {
            throw DXError("IDXGISwapChain::SetFullscreenState failed", hr);
        }
    }
    

    //
    // Gfx context handling
    //

    std::unique_ptr<GfxContext> DX11Window::createGfxContext()
    {
        // note: only one GfxContext should be created at a time.
        // this is enforced by PrimitiveBatch.
        std::unique_ptr<GfxContext> gc(new DX11GfxContext(gfx_driver.getDevice(),
                                                        gfx_driver.getDeviceContext(),
                                                        m_psRenderTargetView.get(),
                                                        m_psSwapChain.get(),
                                                        gfx_driver.getPrimitiveBatch()));
        return gc;
    }


    //
    // Set window icon
    //

    void DX11Window::setIcon(const PixelArray &pixels)
    {
        set_icon->setIcon(pixels);
    }
    

    //
    // Private methods
    //

    // The window procedure
    LRESULT CALLBACK DX11Window::windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
    {
        // we don't want exceptions propagating through into Win32 API
        // so enclose this fn in a try/catch block
        try {            
            // Process the message.
            // If there are any callbacks, we call them directly from this WndProc
            switch (msg) {

            case WM_SETFOCUS:
                // Window has gained input focus
                FindWindow(hwnd).addEvent(OnGainFocus());
                break;

            case WM_KILLFOCUS:
                {
                    // Window has lost input focus
                    DX11Window& window = FindWindow(hwnd);
                    window.addEvent(OnLoseFocus());
                    
                    // Reset modifier state when window is deselected
                    // (as we won't necessarily get the KEYDOWN messages).
                    window.left_alt_state = window.right_alt_state = 
                        window.left_control_state = window.right_control_state = 
                        window.left_shift_state = window.right_shift_state = false;
                }
                break;
            
            case WM_CLOSE:
                {
                    // Notify listeners that the window has been destroyed
                    FindWindow(hwnd).addEvent(OnClose());

                    // Return 0 to prevent DefWindowProc from destroying the window immediately
                    return 0;
                }
                break;
            
            case WM_PAINT:
                // Note: because we are using
                // DXGI_SWAP_EFFECT_DISCARD, we must invalidate the
                // entire window, not just Windows's "update
                // rectangle".
                FindWindow(hwnd).invalidateAll();
                break;
                
            case WM_SIZE:
                {
                    DX11Window &window = FindWindow(hwnd);
                    
                    // resize the back-buffer if necessary
                    if (!window.inhibit_back_buffer_resize) {
                        window.handleWindowResize();
                    }

                    // send minimization / un-minimization messages
                    if (wparam == SIZE_MINIMIZED) {
                        if (!window.is_minimized) {
                            window.addEvent(OnMinimize());
                            window.is_minimized = true;
                        }
                    } else {
                        if (window.is_minimized) {
                            window.addEvent(OnUnminimize());
                            window.is_minimized = false;
                        }
                    }
                }
                break;

            case WM_ENTERSIZEMOVE:
                // Prevent back buffer resizing while user is dragging/resizing the window.
                FindWindow(hwnd).inhibit_back_buffer_resize = true;
                break;

            case WM_EXITSIZEMOVE:
                {
                    DX11Window& window = FindWindow(hwnd);
                    window.inhibit_back_buffer_resize = false;
                    window.handleWindowResize();
                }
                break;
                
            case WM_SYSKEYDOWN:
            case WM_KEYDOWN:
            case WM_SYSKEYUP:
            case WM_KEYUP:
                {
                    DX11Window &window = FindWindow(hwnd);

                    // lparam holds a few flags; decode the ones we are interested in.
                    const bool extended   = (lparam & 0x01000000) != 0;
                    bool prev_state = (lparam & 0x40000000) != 0;  // true if key was previously down
                    const bool new_state  = (msg == WM_SYSKEYDOWN || msg == WM_KEYDOWN);   // true if key is now down
                    const int scancode = (lparam & 0x00FF0000) >> 16;
                    
                    // wparam holds the windows virtual key code.
                    // convert this to a coercri KeyCode.
                    // also update our global modifier flags if required.
                    
                    KeyCode kc = KC_UNKNOWN;
                    
                    // make sure numpad always returns correct keys even if NUMLOCK is off.
                    // source: http://www.swissdelphicenter.ch/en/showcode.php?id=953
                    if (GetKeyState(VK_NUMLOCK) >= 0          // numlock is disabled
                    && !extended) {                           // not an extended key
                        switch (wparam) {
                        case VK_HOME: wparam = VK_NUMPAD7; break;
                        case VK_UP: wparam = VK_NUMPAD8; break;
                        case VK_PRIOR: wparam = VK_NUMPAD9; break;
                        case VK_LEFT: wparam = VK_NUMPAD4; break;
                        case VK_CLEAR: wparam = VK_NUMPAD5; break;
                        case VK_RIGHT: wparam = VK_NUMPAD6; break;
                        case VK_END: wparam = VK_NUMPAD1; break;
                        case VK_DOWN: wparam = VK_NUMPAD2; break;
                        case VK_NEXT: wparam = VK_NUMPAD3; break;
                        case VK_INSERT: wparam = VK_NUMPAD0; break;
                        case VK_DELETE: wparam = VK_DECIMAL; break;
                        }
                    }

                    if (wparam == VK_RETURN) {
                        kc = extended ? KC_KP_ENTER : KC_RETURN;
                        
                    } else if (wparam == VK_MENU) {   // alt
                        if (extended) {
                            kc = KC_RIGHT_ALT;
                            prev_state = window.right_alt_state;
                            window.right_alt_state = new_state;
                        } else {
                            kc = KC_LEFT_ALT;
                            prev_state = window.left_alt_state;
                            window.left_alt_state = new_state;
                        }
                            
                    } else if (wparam == VK_CONTROL) {
                        if (extended) {
                            kc = KC_RIGHT_CONTROL;
                            prev_state = window.right_control_state;
                            window.right_control_state = new_state;
                        } else {
                            kc = KC_LEFT_CONTROL;
                            prev_state = window.left_control_state;
                            window.left_control_state = new_state;
                        }

                    } else if (wparam == VK_SHIFT) {
                        // "extended" flag does not apply to shift, so
                        // we have to check the scancodes
                        if (scancode == scancode_left_shift) {
                            kc = KC_LEFT_SHIFT;
                            prev_state = window.left_shift_state;
                            window.left_shift_state = new_state;
                        } else {
                            kc = KC_RIGHT_SHIFT;
                            prev_state = window.right_shift_state;
                            window.right_shift_state = new_state;
                        }

                    } else {
                        // Try mapping vk to kc
                        kc = VK_to_KC(wparam);
                        if (kc == KC_UNKNOWN) {
                            // Use MapVirtualKey to obtain a Unicode character,
                            // then look this up using Char_to_KC
                            UINT ch = MapVirtualKey(wparam, MAPVK_VK_TO_CHAR) & 0xffff;
                            if (ch != 0) {
                                UINT new_ch;
                                if (ch <= 0xff) new_ch = std::tolower(ch);
                                else new_ch = ch;
                                kc = Char_to_KC(new_ch);
                            }
                        }
                    }

                    // Okay, now we have enough info to send a Key message.
                    bool send_msg = false;
                    KeyEventType type;
                    if (new_state == prev_state) {
                        if (new_state) {
                            send_msg = true;
                            type = KEY_AUTO_REPEAT;
                        }
                    } else {
                        send_msg = true;
                        if (new_state) {
                            type = KEY_PRESSED;
                        } else {
                            type = KEY_RELEASED;
                        }
                    }
                    if (send_msg) {
                        window.addEvent(OnKey(type, kc, window.currentKeyModifiers()));
                    }

                    // special case: if windows sends us a "shift key up" message, this should disengage
                    // BOTH shift keys.
                    if ((kc == KC_LEFT_SHIFT || kc == KC_RIGHT_SHIFT) && new_state == false) {
                        if (window.left_shift_state) {
                            window.left_shift_state = false;
                            window.addEvent(OnKey(KEY_RELEASED, KC_LEFT_SHIFT, window.currentKeyModifiers()));
                        }
                        if (window.right_shift_state) {
                            window.right_shift_state = false;
                            window.addEvent(OnKey(KEY_RELEASED, KC_RIGHT_SHIFT, window.currentKeyModifiers()));
                        }
                    }
                }
                break;

            case WM_UNICHAR:
                if (wparam == UNICODE_NOCHAR) {
                    // tell Windows that we can handle unicode char events
                    return 1;
                }
                // Fall through
                
            case WM_CHAR:
                {
                    DX11Window &window = FindWindow(hwnd);

                    // wparam contains the Unicode character code.

                    // Check for surrogate pairs. Note we assume Windows follows the correct
                    // protocol and does not e.g. send us a lone trailing surrogate.
                    if (wparam >= 0xd800 && wparam <= 0xdbff) {
                        // First half of a surrogate pair
                        window.wm_char_surrogate = wparam;
                        break;  // skip processing

                    } else if (wparam >= 0xdc00 && wparam <= 0xdfff) {
                        // Second half of a surrogate pair
                        wparam = (window.wm_char_surrogate << 10)
                            + wparam
                            + 0x10000 - (0xd800 << 10) - 0xdc00;
                        // continue processing
                    }

                    // We filter out unwanted control characters: 0 to 31 and 127.
                    // (This could probably be made more robust using
                    // some Unicode "is printable" function.)
                    if (wparam >= 32 && wparam != 127) {
                        const KeyModifier mods = window.currentKeyModifiers();
                        OnTextInput oti;
                        oti.str = UTF8String::fromCodePoint(wparam);
                        window.addEvent(oti);
                    }
                }
                break;

            case WM_MOUSEMOVE:
                {
                    DX11Window &window = FindWindow(hwnd);

                    const int x = GET_X_LPARAM(lparam);
                    const int y = GET_Y_LPARAM(lparam);
                    window.addEvent(OnMouseMove(x, y));
                }
                break;

            case WM_LBUTTONDOWN:   // lparam = coordinates
            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
                {
                    DX11Window &window = FindWindow(hwnd);

                    const int x = GET_X_LPARAM(lparam);
                    const int y = GET_Y_LPARAM(lparam);
                    MouseButton mb;
                    if (msg == WM_LBUTTONDOWN) mb = MB_LEFT;
                    else if (msg == WM_RBUTTONDOWN) mb = MB_RIGHT;
                    else mb = MB_MIDDLE;
                    window.addEvent(OnMouseDown(x, y, mb));
                }
                break;

            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_MBUTTONUP:
                {
                    DX11Window &window = FindWindow(hwnd);

                    const int x = GET_X_LPARAM(lparam);
                    const int y = GET_Y_LPARAM(lparam);
                    MouseButton mb;
                    if (msg == WM_LBUTTONUP) mb = MB_LEFT;
                    else if (msg == WM_RBUTTONUP) mb = MB_RIGHT;
                    else mb = MB_MIDDLE;
                    window.addEvent(OnMouseUp(x, y, mb));
                }
                break;

            case WM_MOUSEWHEEL:
                {
                    DX11Window &window = FindWindow(hwnd);

                    // WM_MOUSEWHEEL returns screen coords, we need to convert
                    // these to client coords.
                    POINT p;
                    p.x = GET_X_LPARAM(lparam);
                    p.y = GET_Y_LPARAM(lparam);
                    ScreenToClient(hwnd, &p);
                    
                    short int motion = ((short int)HIWORD(wparam)) / (short int)WHEEL_DELTA;
                    MouseButton mb;
                    if (motion < 0) {
                        mb = MB_WHEEL_DOWN;
                        motion = -motion;
                    } else {
                        mb = MB_WHEEL_UP;
                    }
                    for (short int i = 0; i < motion; ++i) {
                        window.addEvent(OnMouseDown(p.x, p.y, mb));
                        window.addEvent(OnMouseUp(p.x, p.y, mb));
                    }
                }
                break;

            case WM_SYSCOMMAND:
                // Disable the ALT and F10 keys
                if (wparam == SC_KEYMENU) return 0;
                break;
            }

            return DefWindowProcW(hwnd, msg, wparam, lparam);

        } catch (std::exception &e) {
            g_win_proc_error_msg = e.what();
            return -1;

        } catch (...) {
            // Unknown exception, we can't do anything with it
            return -1;
        }
    }

    bool DX11Window::checkShiftKeys()
    {
        // A "feature" of windows messages is that if both shift keys are held down, and then one is 
        // released (while still holding the other), we do not get a WM_KEYUP message. (We only get 
        // the message after both shift keys are released.) 
        // We can work around this by manually checking the shift key state
        // every time events are polled...
        
        bool did_something = false;

        if (left_shift_state && right_shift_state) {
            if ((GetAsyncKeyState(VK_LSHIFT) & 0x8000) == 0) {
                left_shift_state = false;
                addEvent(OnKey(KEY_RELEASED, KC_LEFT_SHIFT, currentKeyModifiers()));
                did_something = true;
            }
            if ((GetAsyncKeyState(VK_RSHIFT) & 0x8000) == 0) {
                right_shift_state = false;
                addEvent(OnKey(KEY_RELEASED, KC_RIGHT_SHIFT, currentKeyModifiers()));
                did_something = true;
            }
        }

        return did_something;
    }

    KeyModifier DX11Window::currentKeyModifiers() const
    {
        unsigned int mod = 0;
        if (left_alt_state || right_alt_state) mod |= KM_ALT;
        if (left_control_state || right_control_state) mod |= KM_CONTROL;
        if (left_shift_state || right_shift_state) mod |= KM_SHIFT;
        return KeyModifier(mod);
    }


    void DX11Window::handleWindowResize()
    {
        // Find the current window size
        RECT rect;
        if (!GetClientRect(hwnd, &rect)) {
            throw DXError("GetClientRect failed", HRESULT_FROM_WIN32(GetLastError()));
        }
        const int width = rect.right;
        const int height = rect.bottom;
        
        if (m_psSwapChain.get()) {

            // We have to release the render target view, resize the
            // swap chain, then recreate the render target view.
            m_psRenderTargetView.reset(0);
            
            HRESULT hr = m_psSwapChain->ResizeBuffers(0,   // preserve existing number of buffers
                                                      width,
                                                      height,
                                                      DXGI_FORMAT_UNKNOWN,   // preserve current format
                                                      0);   // do not allow display mode changes
            if (FAILED(hr)) {
                throw DXError("IDXGISwapChain::ResizeBuffers failed", hr);
            }

            createRenderTargetView();
        }

        // Call any Coercri resize-listeners
        for (std::vector<WindowListener*>::iterator it = listeners.begin(); it != listeners.end(); ++it) {
            (*it)->onResize(width, height);
        }

        // Invalidate the whole window after a resize (forces everything to repaint).
        invalid_region.clear();
        invalid_region.addRectangle(Rectangle(0,0,width,height));
    }

    bool DX11Window::pollEvents()
    {
        if (events.empty()) {
            return checkShiftKeys();
        } else {
            events.front()->dispatch(*this);
            events.pop_front();
            return true;
        }
    }
}
