/*
 * FILE:
 *   enet_network_connection.cpp
 *
 * AUTHOR:
 *   Stephen Thompson
 *
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2024.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0, 
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "enet_network_connection.hpp"

#include "../core/coercri_error.hpp"

#include <iterator>

namespace Coercri {

    EnetNetworkConnection::EnetNetworkConnection(ENetHost *host, const std::string &hostname, int port)
        : peer(0), state(PENDING)
    {
        ENetAddress address;
        enet_address_set_host(&address, hostname.c_str());
        address.port = port;

#ifdef COERCRI_USE_ENET_1_3
        // enet 1.3.x
        peer = enet_host_connect(host, &address, 1, 0);  // open 1 channel only. no user data supplied.
#else
        // enet 1.2.x
        peer = enet_host_connect(host, &address, 1);  // open 1 channel only.
#endif
        if (!peer) {
            throw CoercriError("EnetNetworkConnection: enet_host_connect failed");
        }

        peer->data = this;
    }

    EnetNetworkConnection::EnetNetworkConnection(ENetPeer *peer_)
        : peer(peer_), state(CONNECTED)
    {
        peer->data = this;
    }

    EnetNetworkConnection::~EnetNetworkConnection()
    {
        while (!queued_packets.empty()) {
            enet_packet_destroy(queued_packets.front());
            queued_packets.pop();
        }
        if (peer) {
            // Use enet_peer_disconnect_now rather than enet_peer_reset
            // (the only real difference is that disconnect_now will take
            // one last shot at sending a DISCONNECT message before
            // resetting).
            enet_peer_disconnect_now(peer, 0);
            peer->data = 0;
        }
    }

    EnetNetworkConnection::State EnetNetworkConnection::getState() const
    {
        return state;
    }

    void EnetNetworkConnection::close()
    {
        if (peer && state != CLOSED && state != FAILED) {
            state = CLOSED;

            // use enet_peer_disconnect_later, this ensures any queued
            // packets are sent first.
            enet_peer_disconnect_later(peer, 0);
        }
        // NOTE: Keep the link to the peer open (ie dont zero out peer->data and peer),
        // as the peer is still "active" while we wait for the disconnect message.
    }

    void EnetNetworkConnection::send(const std::vector<unsigned char> &buf)
    {
        if (state == CONNECTED && peer) {
            ENetPacket *packet = enet_packet_create(&buf[0], buf.size(), ENET_PACKET_FLAG_RELIABLE);
            enet_peer_send(peer, 0, packet);
        } else if (state == PENDING) {
            // Can't send yet, but will send as soon as connection becomes established.
            outgoing_packets.push(buf);
        }
        // Packets send to a CLOSED or FAILED connection are silently dropped.
    }

    void EnetNetworkConnection::receive(std::vector<unsigned char> &buf)
    {
        buf.clear();
        while (!queued_packets.empty()) {
            unsigned char* ptr = static_cast<unsigned char*>(queued_packets.front()->data);
            std::copy(ptr, ptr + queued_packets.front()->dataLength, std::back_inserter(buf));
            enet_packet_destroy(queued_packets.front());
            queued_packets.pop();
        }
    }

    std::string EnetNetworkConnection::getAddress()
    {
        char buf[1024];
        enet_address_get_host_ip(&peer->address, buf, sizeof(buf));
        buf[sizeof(buf)-1] = 0;
        return std::string(buf);
    }

    int EnetNetworkConnection::getPingTime()
    {
        // NOTE: 'averagePing' is a custom modification to enet.
        if (peer) return int(peer->averagePing+0.5f);
        else return 0;
    }

    void EnetNetworkConnection::onReceiveAcknowledgment()
    {
        state = CONNECTED;
        while (!outgoing_packets.empty()) {
            send(outgoing_packets.front());
            outgoing_packets.pop();
        }
    }

    void EnetNetworkConnection::onReceivePacket(ENetPacket *packet)
    {
        queued_packets.push(packet);
    }

    void EnetNetworkConnection::onDisconnect()
    {
        // This is called when we get an ENet disconnect event. This
        // means either an existing connection timed out or was
        // closed, or an attempt to establish a new connection timed
        // out or otherwise failed.
        if (state == CONNECTED) {
            state = CLOSED;
        } else {
            state = FAILED;
        }

        // Break the link to the peer.
        peer->data = 0;
        peer = 0;
    }
}
