/*
 * FILE:
 *   enet_network_driver.cpp
 *
 * AUTHOR:
 *   Stephen Thompson
 *
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2025.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0, 
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "enet_network_connection.hpp"
#include "enet_network_driver.hpp"

#include "../core/coercri_error.hpp"

namespace Coercri {

    namespace {
        template<class T>
        struct PtrEq {
            PtrEq(T *p_) : p(p_) { }
            bool operator()(const boost::shared_ptr<T> &q) const { return q.get() == p; }
            T* p;
        };

        template<class T>
        struct WeakPtrExpiredOrEquals {
            WeakPtrExpiredOrEquals(T *p_) : p(p_) { }
            bool operator()(const boost::weak_ptr<T> &q) const {
                boost::shared_ptr<T> qq = q.lock();
                return !qq || qq.get() == p;
            }
            T* p;
        };
    }

    int EnetNetworkDriver::enet_init_count = 0;

    EnetNetworkDriver::EnetNetworkDriver(int max_inc, int max_outgoing, bool compress)
        : incoming_host(0), outgoing_host(0), server_port(0), server_enabled(false), max_incoming(max_inc),
          use_compression(compress)
    {
        if (enet_init_count == 0) {
            if (enet_initialize() != 0) {
                throw CoercriError("enet initialization failed");
            }
        }
        ++enet_init_count;

        // create the outgoing_host. (incoming_host only created as needed.)
        outgoing_host = enet_host_create(0, max_outgoing, 0, 0, 0);
        if (use_compression && outgoing_host) {
            enet_host_compress_with_range_coder(outgoing_host);
        }
        if (!outgoing_host) {
            throw CoercriError("EnetNetworkDriver: enet_host_create failed");
        }
    }

    EnetNetworkDriver::~EnetNetworkDriver()
    {
        // If any connections still exist then tell them that they are
        // about to be disconnected. This will clear their "peer"
        // pointer, which stops them calling enet_peer_disconnect on a
        // peer that no longer exists.
        // This is defensive programming because the caller really
        // ought to destroy all NetworkConnections before destroying the
        // NetworkDriver, but in case they don't, the following code
        // will prevent a crash!
        for (auto &weak_conn : connections_in) {
            auto conn = weak_conn.lock();
            if (conn) conn->onDisconnect();
        }
        for (auto &weak_conn : connections_out) {
            auto conn = weak_conn.lock();
            if (conn) conn->onDisconnect();
        }

        // Close down ENet
        if (outgoing_host) enet_host_destroy(outgoing_host);
        if (incoming_host) enet_host_destroy(incoming_host);
        --enet_init_count;
        if (enet_init_count == 0) {
            enet_deinitialize();
        }
    }

    boost::shared_ptr<NetworkConnection> EnetNetworkDriver::openConnection(const std::string &hostname, int port_number)
    {
        boost::unique_lock lock(mutex);
        boost::shared_ptr<EnetNetworkConnection> new_conn(new EnetNetworkConnection(outgoing_host, hostname, port_number));
        connections_out.push_back(new_conn);
        return new_conn;
    }

    void EnetNetworkDriver::setServerPort(int port)
    {
        boost::unique_lock lock(mutex);

        if (server_enabled) throw CoercriError("Cannot set server port while server is enabled");

        server_port = port;
    }

    // mutex should be locked when this is called
    void EnetNetworkDriver::createIncomingHostIfNeeded()
    {
        if (!incoming_host && server_enabled) {
            // Create the incoming host
            ENetAddress address;
            address.host = ENET_HOST_ANY;
            address.port = server_port;
            incoming_host = enet_host_create(&address, max_incoming, 0, 0, 0);
            if (use_compression && incoming_host) {
                enet_host_compress_with_range_coder(incoming_host);
            }
            if (!incoming_host) {
                server_enabled = false;
                throw CoercriError("EnetNetworkDriver: enet_host_create failed");
            }
        }
    }

    // mutex should be locked when this is called
    void EnetNetworkDriver::destroyIncomingHost()
    {
        if (incoming_host) {
            enet_host_destroy(incoming_host);
            incoming_host = 0;
        }
    }
    
    void EnetNetworkDriver::enableServer(bool enabled)
    {
        boost::unique_lock lock(mutex);

        server_enabled = enabled;
        
        createIncomingHostIfNeeded();
        
        if (!server_enabled && incoming_host) {

            // Close any existing connections (into the old server)
            // if applicable.
            bool found_existing_connection = false;
            for (auto& conn_weak : connections_in) {
                boost::shared_ptr<EnetNetworkConnection> conn = conn_weak.lock();
                if (conn) {
                    conn->close();
                    found_existing_connection = true;
                }
            }

            // Note: if existing connections were found, we don't
            // destroy the host immediately; instead we wait for ENet
            // to clean things up, and then destroy the host in
            // serviceHost().
            // If existing connections were *not* found, then we can
            // destroy the host right away.
            if (!found_existing_connection) {
                destroyIncomingHost();
            }
        }
    }
    
    EnetNetworkDriver::Connections EnetNetworkDriver::pollIncomingConnections()
    {
        boost::unique_lock lock(mutex);

        Connections result;
        std::swap(new_connections_in, result);
        return result;
    }

    // mutex should be locked when this is called
    bool EnetNetworkDriver::serviceHost(ENetHost *host)
    {
        if (!host) return false;

        ENetEvent event;
        int result = enet_host_service(host, &event, 0);
        
        if (result < 0) {
            throw CoercriError("EnetNetworkDriver: enet_host_service failed");
        } else if (result == 0) {
            return false;
        } else {
            // got an event
            switch (event.type) {
            case ENET_EVENT_TYPE_CONNECT:
                if (event.peer->data) {
                    // One of my outgoing connections has been acknowledged by the remote server.
                    EnetNetworkConnection *conn = static_cast<EnetNetworkConnection*>(event.peer->data);
                    conn->onReceiveAcknowledgment();
                } else {
                    // This is a new incoming connection.
                    if (server_enabled) {
                        boost::shared_ptr<EnetNetworkConnection> new_conn(new EnetNetworkConnection(event.peer));
                        connections_in.push_back(new_conn);
                        new_connections_in.push_back(new_conn);
                    } else {
                        // refuse the connection
                        enet_peer_disconnect(event.peer, 0);
                    }
                }
                break;

            case ENET_EVENT_TYPE_DISCONNECT:
                // We've been disconnected. Note that we get this event for both timeouts and explicit disconnects.
                {
                    EnetNetworkConnection *conn = static_cast<EnetNetworkConnection*>(event.peer->data);
                    conn->onDisconnect();  // Goes into disconnected state, and breaks link to ENetPeer object.

                    // Remove the connection from my vectors
                    // (also remove any "expired" weak_ptrs at the same time)
                    connections_out.erase(std::remove_if(connections_out.begin(), connections_out.end(),
                                                         WeakPtrExpiredOrEquals<EnetNetworkConnection>(conn)),
                                          connections_out.end());
                    connections_in.erase(std::remove_if(connections_in.begin(), connections_in.end(),
                                                        WeakPtrExpiredOrEquals<EnetNetworkConnection>(conn)),
                                         connections_in.end());
                    new_connections_in.erase(std::remove_if(new_connections_in.begin(), new_connections_in.end(),
                                                            PtrEq<NetworkConnection>(conn)),
                                             new_connections_in.end());

                    // If server is disabled and there are no incoming connections left, then we may
                    // destroy the server host
                    if (connections_in.empty() && !server_enabled) {
                        destroyIncomingHost();
                    }
                }
                break;

            case ENET_EVENT_TYPE_RECEIVE:
                // A packet has been received.
                {
                    EnetNetworkConnection* from_conn = static_cast<EnetNetworkConnection*>(event.peer->data);
                    from_conn->onReceivePacket(event.packet);
                }
                break;
            }
            return true;
        }
    }

    bool EnetNetworkDriver::doEvents()
    {
        boost::unique_lock lock(mutex);

        bool did_something = false;

        if (!connections_out.empty()) {
            // Update the outgoing connections
            did_something = serviceHost(outgoing_host) || did_something;
        }

        // Update the incoming connections (if server enabled)
        did_something = serviceHost(incoming_host) || did_something;

        // Clean up expired weak ptrs
        connections_out.erase(std::remove_if(connections_out.begin(), connections_out.end(),
                                             WeakPtrExpiredOrEquals<EnetNetworkConnection>(nullptr)),
                              connections_out.end());
        connections_in.erase(std::remove_if(connections_in.begin(), connections_in.end(),
                                            WeakPtrExpiredOrEquals<EnetNetworkConnection>(nullptr)),
                             connections_in.end());

        // Return result
        return did_something;
    }

    bool EnetNetworkDriver::outstandingConnections()
    {
        boost::unique_lock lock(mutex);

        return !connections_in.empty() || !connections_out.empty() || !new_connections_in.empty();
    }
}
