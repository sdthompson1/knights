/*
 * FILE:
 *   sdl_sound_driver.cpp
 *
 * AUTHOR:
 *   Stephen Thompson
 *
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2024.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0, 
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "sdl_sound_driver.hpp"
#include "../core/sdl_error.hpp"
#include "../core/istream_rwops.hpp"
#include "../../sound/sound.hpp"

#include "boost/noncopyable.hpp"

namespace Coercri {

    namespace {
        bool g_sound_open;   // Can only open the audio device once!

        void FlipEndian(Uint8 *data, int nbytes)
        {
            while (nbytes > 0) {
                std::swap(*data, *(data+1));
                data += 2;
                nbytes -= 2;
            }
        }
    }

    struct SDLSound : Sound {
        Uint16 *data;
        Uint32 len;
        SDLSound(Uint16 *d, Uint32 l) : data(d), len(l) { }
        ~SDLSound() { SDL_FreeWAV(reinterpret_cast<Uint8*>(data)); }
    };

    struct Voice {
        float pos;
        boost::shared_ptr<SDLSound> sound;
        int freq;
    };

    SDLSoundDriver::SDLSoundDriver(float vf)
        : audio_subsystem_handle(SDL_INIT_AUDIO), volume_factor(vf)
    {
        if (g_sound_open) {
            throw CoercriError("Sound already open");
        }

        SDL_AudioSpec desired;
        memset(&desired, 0, sizeof(desired));
        memset(&spec, 0, sizeof(spec));
        desired.freq = 22050;
        desired.format = AUDIO_S16SYS;
        desired.channels = 1;  // We don't support stereo at the moment
        desired.samples = 1024;
        desired.callback = audioCallback;
        desired.userdata = this;

        const int err = SDL_OpenAudio(&desired, &spec);
        if (err < 0) {
            throw SDLError("Couldn't open audio");
        }

        SDL_PauseAudio(0);
        g_sound_open = true;
    }

    SDLSoundDriver::~SDLSoundDriver()
    {
        SDL_PauseAudio(1);
        SDL_CloseAudio();
        g_sound_open = false;
    }

    boost::shared_ptr<Sound> SDLSoundDriver::loadSound(boost::shared_ptr<std::istream> str)
    {
        SDL_AudioSpec spec;
        memset(&spec, 0, sizeof(spec));

        Uint8 *data = 0;
        Uint32 len = 0;

        SDL_RWops * rwops = CreateRWOpsForIstream(str);
        SDL_LoadWAV_RW(rwops, 1, &spec, &data, &len);

        if (!data) {
            throw SDLError("Failed to load sound file");
        }
        if (spec.format != AUDIO_S16LSB && spec.format != AUDIO_S16MSB) {
            throw CoercriError("Unsupported sound format");
        }
        if (spec.format != AUDIO_S16SYS) {
            FlipEndian(data, len);
        }

        boost::shared_ptr<Sound> sound(new SDLSound(reinterpret_cast<Uint16*>(data), len/2));
        return sound;
    }

    void SDLSoundDriver::playSound(boost::shared_ptr<Sound> sound, int frequency)
    {
        boost::shared_ptr<SDLSound> sdl_sound = boost::dynamic_pointer_cast<SDLSound>(sound);
        if (sdl_sound) {
            // Add a new voice playing this sample
            Voice v;
            v.pos = 0;
            v.sound = sdl_sound;
            v.freq = frequency;
            SDL_LockAudio();
            voices.push_front(v);
            SDL_UnlockAudio();
        }
    }

    void SDLSoundDriver::audioCallback(void *userdata, Uint8 *stream, int len)
    {
        SDLSoundDriver* snd_drv = static_cast<SDLSoundDriver*>(userdata);
        Sint16 *buf = reinterpret_cast<Sint16*>(stream);

        // Zero out the buffer
        memset(buf, 0, len);

        // For each voice currently playing
        for (std::list<Voice>::iterator it = snd_drv->voices.begin(); it != snd_drv->voices.end(); ) {

            bool erase = false;

            // For each data point
            for (int n = 0; n < len/2; ++n) {
                if (it->pos >= (it->sound->len - 2)) {
                    erase = true;
                    break;
                } else {
                    // Linearly interpolate
                    const int p1 = int(it->pos);
                    const float lambda = it->pos - p1;
                    const Sint16 x1 = it->sound->data[p1];
                    const Sint16 x2 = it->sound->data[p1 + 1];
                    const float interp = (1-lambda)*x1 + lambda*x2;

                    const Sint32 new_val = buf[n] + Sint16(snd_drv->volume_factor * interp);
                    if (new_val >= 32767) {
                        buf[n] = 32767;
                    } else if (new_val <= -32768) {
                        buf[n] = -32768;
                    } else {
                        buf[n] = new_val;
                    }

                    it->pos += (float(it->freq) / snd_drv->spec.freq);
                }
            }
            if (erase) {
                std::list<Voice>::iterator it2 = it++;
                snd_drv->voices.erase(it2);
            } else {
                ++it;
            }
        }
    }
}
