/*
 * FILE:
 *   sdl_gfx_driver.cpp
 *
 * AUTHOR:
 *   Stephen Thompson <stephen@solarflare.org.uk>
 *
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2014.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0, 
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "sdl_gfx_context.hpp"
#include "sdl_gfx_driver.hpp"
#include "sdl_graphic.hpp"
#include "sdl_window.hpp"
#include "../../core/coercri_error.hpp"
#include "../../gfx/mouse_button.hpp"
#include "../../gfx/rectangle.hpp"
#include "../../gfx/region.hpp"
#include "../../gfx/window_listener_funcs.hpp"

#include "SDL.h"
#include "boost/weak_ptr.hpp"
#include <map>

#ifdef WIN32
#include "SDL_syswm.h"
#include <windows.h>
#ifdef MB_RIGHT
#undef MB_RIGHT
#endif
#endif

namespace Coercri {

    // SDL only supports one window at a time - we store a global
    // pointer to this Window here.
    boost::weak_ptr<SDLWindow> g_sdl_window;
    unsigned int g_sdl_required_flags;
    bool g_sdl_has_focus;
    bool g_sdl_is_minimized;

    namespace {

        // Global key tables
        std::map<SDLKey, KeyCode> g_keytable;
        std::map<SDLKey, bool> g_keystate;  // true if key down, false if up.

        void InitKeyTable()
        {
            if (!g_keytable.empty()) return;  // already initialized

            g_keytable[SDLK_BACKSPACE] = KC_BACKSPACE;
            g_keytable[SDLK_TAB] = KC_TAB;
            g_keytable[SDLK_CLEAR] = KC_CLEAR;
            g_keytable[SDLK_RETURN] = KC_RETURN;
            g_keytable[SDLK_PAUSE] = KC_PAUSE;
            g_keytable[SDLK_ESCAPE] = KC_ESCAPE;
            g_keytable[SDLK_SPACE] = KC_SPACE;
            g_keytable[SDLK_EXCLAIM] = KC_EXCLAIM;
            g_keytable[SDLK_QUOTEDBL] = KC_DOUBLE_QUOTE;
            g_keytable[SDLK_HASH] = KC_HASH;
            g_keytable[SDLK_DOLLAR] = KC_DOLLAR;
            g_keytable[SDLK_AMPERSAND] = KC_AMPERSAND;
            g_keytable[SDLK_QUOTE] = KC_SINGLE_QUOTE;
            g_keytable[SDLK_LEFTPAREN] = KC_LEFT_PAREN;
            g_keytable[SDLK_RIGHTPAREN] = KC_RIGHT_PAREN;
            g_keytable[SDLK_ASTERISK] = KC_ASTERISK;
            g_keytable[SDLK_PLUS] = KC_PLUS;
            g_keytable[SDLK_COMMA] = KC_COMMA;
            g_keytable[SDLK_MINUS] = KC_MINUS;
            g_keytable[SDLK_PERIOD] = KC_PERIOD;
            g_keytable[SDLK_SLASH] = KC_SLASH;
            g_keytable[SDLK_0] = KC_0;
            g_keytable[SDLK_1] = KC_1;
            g_keytable[SDLK_2] = KC_2;
            g_keytable[SDLK_3] = KC_3;
            g_keytable[SDLK_4] = KC_4;
            g_keytable[SDLK_5] = KC_5;
            g_keytable[SDLK_6] = KC_6;
            g_keytable[SDLK_7] = KC_7;
            g_keytable[SDLK_8] = KC_8;
            g_keytable[SDLK_9] = KC_9;
            g_keytable[SDLK_COLON] = KC_COLON;
            g_keytable[SDLK_SEMICOLON] = KC_SEMICOLON;
            g_keytable[SDLK_LESS] = KC_LESS;
            g_keytable[SDLK_EQUALS] = KC_EQUALS;
            g_keytable[SDLK_GREATER] = KC_GREATER;
            g_keytable[SDLK_QUESTION] = KC_QUESTION;
            g_keytable[SDLK_AT] = KC_AT;
            g_keytable[SDLK_LEFTBRACKET] = KC_LEFT_BRACKET;
            g_keytable[SDLK_BACKSLASH] = KC_BACKSLASH;
            g_keytable[SDLK_RIGHTBRACKET] = KC_RIGHT_BRACKET;
            g_keytable[SDLK_CARET] = KC_CARET;
            g_keytable[SDLK_UNDERSCORE] = KC_UNDERSCORE;
            g_keytable[SDLK_BACKQUOTE] = KC_BACKQUOTE;
            g_keytable[SDLK_a] = KC_A;
            g_keytable[SDLK_b] = KC_B;
            g_keytable[SDLK_c] = KC_C;
            g_keytable[SDLK_d] = KC_D;
            g_keytable[SDLK_e] = KC_E;
            g_keytable[SDLK_f] = KC_F;
            g_keytable[SDLK_g] = KC_G;
            g_keytable[SDLK_h] = KC_H;
            g_keytable[SDLK_i] = KC_I;
            g_keytable[SDLK_j] = KC_J;
            g_keytable[SDLK_k] = KC_K;
            g_keytable[SDLK_l] = KC_L;
            g_keytable[SDLK_m] = KC_M;
            g_keytable[SDLK_n] = KC_N;
            g_keytable[SDLK_o] = KC_O;
            g_keytable[SDLK_p] = KC_P;
            g_keytable[SDLK_q] = KC_Q;
            g_keytable[SDLK_r] = KC_R;
            g_keytable[SDLK_s] = KC_S;
            g_keytable[SDLK_t] = KC_T;
            g_keytable[SDLK_u] = KC_U;
            g_keytable[SDLK_v] = KC_V;
            g_keytable[SDLK_w] = KC_W;
            g_keytable[SDLK_x] = KC_X;
            g_keytable[SDLK_y] = KC_Y;
            g_keytable[SDLK_z] = KC_Z;
            g_keytable[SDLK_DELETE] = KC_DELETE;
            g_keytable[SDLK_KP0] = KC_KP_0;
            g_keytable[SDLK_KP1] = KC_KP_1;
            g_keytable[SDLK_KP2] = KC_KP_2;
            g_keytable[SDLK_KP3] = KC_KP_3;
            g_keytable[SDLK_KP4] = KC_KP_4;
            g_keytable[SDLK_KP5] = KC_KP_5;
            g_keytable[SDLK_KP6] = KC_KP_6;
            g_keytable[SDLK_KP7] = KC_KP_7;
            g_keytable[SDLK_KP8] = KC_KP_8;
            g_keytable[SDLK_KP9] = KC_KP_9;
            g_keytable[SDLK_KP_PERIOD] = KC_KP_PERIOD;
            g_keytable[SDLK_KP_DIVIDE] = KC_KP_DIVIDE;
            g_keytable[SDLK_KP_MULTIPLY] = KC_KP_MULTIPLY;
            g_keytable[SDLK_KP_MINUS] = KC_KP_MINUS;
            g_keytable[SDLK_KP_PLUS] = KC_KP_PLUS;
            g_keytable[SDLK_KP_ENTER] = KC_KP_ENTER;
            g_keytable[SDLK_KP_EQUALS] = KC_KP_EQUALS;
            g_keytable[SDLK_UP] = KC_UP;
            g_keytable[SDLK_DOWN] = KC_DOWN;
            g_keytable[SDLK_RIGHT] = KC_RIGHT;
            g_keytable[SDLK_LEFT] = KC_LEFT;
            g_keytable[SDLK_INSERT] = KC_INSERT;
            g_keytable[SDLK_HOME] = KC_HOME;
            g_keytable[SDLK_END] = KC_END;
            g_keytable[SDLK_PAGEUP] = KC_PAGE_UP;
            g_keytable[SDLK_PAGEDOWN] = KC_PAGE_DOWN;
            g_keytable[SDLK_F1] = KC_F1;
            g_keytable[SDLK_F2] = KC_F2;
            g_keytable[SDLK_F3] = KC_F3;
            g_keytable[SDLK_F4] = KC_F4;
            g_keytable[SDLK_F5] = KC_F5;
            g_keytable[SDLK_F6] = KC_F6;
            g_keytable[SDLK_F7] = KC_F7;
            g_keytable[SDLK_F8] = KC_F8;
            g_keytable[SDLK_F9] = KC_F9;
            g_keytable[SDLK_F10] = KC_F10;
            g_keytable[SDLK_F11] = KC_F11;
            g_keytable[SDLK_F12] = KC_F12;
            g_keytable[SDLK_F13] = KC_F13;
            g_keytable[SDLK_F14] = KC_F14;
            g_keytable[SDLK_F15] = KC_F15;
            g_keytable[SDLK_NUMLOCK] = KC_NUM_LOCK;
            g_keytable[SDLK_CAPSLOCK] = KC_CAPS_LOCK;
            g_keytable[SDLK_SCROLLOCK] = KC_SCROLL_LOCK;
            g_keytable[SDLK_RSHIFT] = KC_RIGHT_SHIFT;
            g_keytable[SDLK_LSHIFT] = KC_LEFT_SHIFT;
            g_keytable[SDLK_RCTRL] = KC_RIGHT_CONTROL;
            g_keytable[SDLK_LCTRL] = KC_LEFT_CONTROL;
            g_keytable[SDLK_RALT] = KC_RIGHT_ALT;            
            g_keytable[SDLK_LALT] = KC_LEFT_ALT;
            g_keytable[SDLK_RMETA] = KC_RIGHT_META;
            g_keytable[SDLK_LMETA] = KC_LEFT_META;
            g_keytable[SDLK_LSUPER] = KC_LEFT_WINDOWS;
            g_keytable[SDLK_RSUPER] = KC_RIGHT_WINDOWS;
            g_keytable[SDLK_MODE] = KC_MODE;
            g_keytable[SDLK_COMPOSE] = KC_COMPOSE;
            g_keytable[SDLK_HELP] = KC_HELP;
            g_keytable[SDLK_PRINT] = KC_PRINT_SCREEN;
            g_keytable[SDLK_SYSREQ] = KC_SYSREQ;
            g_keytable[SDLK_BREAK] = KC_BREAK;
            g_keytable[SDLK_MENU] = KC_MENU;
            g_keytable[SDLK_POWER] = KC_POWER;
            g_keytable[SDLK_EURO] = KC_EURO;
            g_keytable[SDLK_UNDO] = KC_UNDO;
        }

        int GetModifiers(unsigned int sdl_mod)
        {
            int result = 0;
            if (sdl_mod & KMOD_ALT) result += KM_ALT;
            if (sdl_mod & KMOD_CTRL) result += KM_CONTROL;
            if (sdl_mod & KMOD_SHIFT) result += KM_SHIFT;
            return result;
        }

        MouseButton MouseButtonFromSDL(int m, bool &error)
        {
            switch (m) {
            case SDL_BUTTON_LEFT: return MB_LEFT;
            case SDL_BUTTON_RIGHT: return MB_RIGHT;
            case SDL_BUTTON_MIDDLE: return MB_MIDDLE;
            case SDL_BUTTON_WHEELUP: return MB_WHEEL_UP;
            case SDL_BUTTON_WHEELDOWN: return MB_WHEEL_DOWN;
            default: error = true; return MB_LEFT;
            }
        }

        //
        // Handle SDL events.
        //

        void DoEvent(const SDL_Event &event, int & surrogate_pair_start)
        {
            boost::shared_ptr<SDLWindow> window(g_sdl_window.lock());
            if (!window) return;

            switch (event.type) {
            case SDL_VIDEOEXPOSE:
                {
                    // Invalidate the entire screen (I don't think SDL
                    // gives more detailed info about the invalid
                    // rectangle?)
                    SDL_Surface * vid_surf = SDL_GetVideoSurface();
                    Rectangle rectangle(0, 0, vid_surf->w, vid_surf->h);
                    window->invalidateRectangle(rectangle);
                }
                break;

            case SDL_QUIT:
                window->forEachListener(OnClose());
                break;

            case SDL_ACTIVEEVENT:
                if ((event.active.state & SDL_APPINPUTFOCUS) != 0) {
                    // Window focus gained or lost.
                    if (event.active.gain) {
                        g_sdl_has_focus = true;
                        window->forEachListener(OnGainFocus());

                    } else {
                        g_sdl_has_focus = false;
                        window->forEachListener(OnLoseFocus());
                            
                        // reset all keys to "up" state when window loses focus.
                        // this prevents a KE_PRESSED being misinterpreted as a KE_AUTO_REPEAT
                        // because we missed the keyup event.
                        g_keystate.clear();
                    }
                }
                if ((event.active.state & SDL_APPACTIVE) != 0) {
                    // Activation/deactivation (i.e. minimization or un-minimization).
                    if (event.active.gain) {
                        // sometimes we get an "active" event even when the app
                        // is already non-minimized, so filter those out
                        if (g_sdl_is_minimized) {
                            window->forEachListener(OnUnminimize());
                        }
                        g_sdl_is_minimized = false;
                    } else {
                        if (!g_sdl_is_minimized) {
                            window->forEachListener(OnMinimize());
                        }
                        g_sdl_is_minimized = true;
                    }
                }
                break;

            case SDL_VIDEORESIZE:
                {
                    // 1) Must reset the video mode. (This will also trigger a repaint.)
                    SDL_SetVideoMode(event.resize.w, event.resize.h, 0, g_sdl_required_flags);
                    window->invalidateAll();
                    
                    // 2) Inform the WindowListeners of the resize.
                    window->forEachListener(OnResize(event.resize.w, event.resize.h));
                }
                break;

            case SDL_KEYDOWN:
            case SDL_KEYUP:
                {
                    // Find out what kind of key event this is.
                    const SDLKey keysym = event.key.keysym.sym;
                    KeyEventType type;
                    if (event.type == SDL_KEYDOWN) {
                        if (g_keystate[keysym]) {
                            type = KEY_AUTO_REPEAT;
                        } else {
                            g_keystate[keysym] = true;
                            type = KEY_PRESSED;
                        }
                    } else {
                        g_keystate[keysym] = false;
                        type = KEY_RELEASED;
                    }
                    
                    // Find the corresponding KeyCode.
                    KeyCode kc = KC_UNKNOWN;
                    std::map<SDLKey, KeyCode>::const_iterator key_it = g_keytable.find(keysym);
                    if (key_it != g_keytable.end()) kc = key_it->second;
                   
                    // Find whether SDL has provided a Unicode character for us
                    // (filtering out unwanted control characters).
                    int unicode = 0;
                    if (type != KEY_RELEASED) {

                        unicode = event.key.keysym.unicode;
                        if (unicode < 32 || unicode == 127) unicode = 0;

                        if (unicode >= 0xd800 && unicode <= 0xdbff) {
                            // first half of surrogate pair
                            surrogate_pair_start = unicode;
                            unicode = 0;
                        } else if (unicode >= 0xdc00 && unicode <= 0xdfff) {
                            // second half of surrogate pair
                            unicode = (surrogate_pair_start << 10)
                                + unicode
                                + 0x10000 - (0xd800 << 10) - 0xdc00;
                        }
                    }

                    // Find the modifiers.
                    const int modifiers = GetModifiers(event.key.keysym.mod);
                    
                    // Send the key event, if required.
                    if (kc != KC_UNKNOWN) {
                        window->forEachListener(OnKey(type, kc, KeyModifier(modifiers)));
                    }

                    // Send the text input event, if required.
                    if (unicode != 0 && (modifiers & KM_CONTROL) == 0) {
                        OnTextInput oti;
                        oti.str = UTF8String::fromCodePoint(unicode);
                        // Send the event.
                        window->forEachListener(oti);
                    }
                }
                break;

            case SDL_MOUSEBUTTONDOWN:
                {
                    bool err = false;
                    const MouseButton mb = MouseButtonFromSDL(event.button.button, err);
                    if (!err) {
                        window->forEachListener(OnMouseDown(event.button.x, event.button.y, mb));
                    }
                }
                break;

            case SDL_MOUSEBUTTONUP:
                {
                    bool err = false;
                    const MouseButton mb = MouseButtonFromSDL(event.button.button, err);
                    if (!err) {
                        window->forEachListener(OnMouseUp(event.button.x, event.button.y, mb));
                    }
                }
                break;

            case SDL_MOUSEMOTION:
                window->forEachListener(OnMouseMove(event.motion.x, event.motion.y));
                break;
            }
        }

    } // namespace


    //
    // SDLGfxDriver implementation
    //
    
    SDLGfxDriver::SDLGfxDriver()
        : video_subsystem(SDL_INIT_VIDEO)
    {
        const SDL_VideoInfo* info = SDL_GetVideoInfo();
        desktop_width = info->current_w;
        desktop_height = info->current_h;
        
        InitKeyTable();
        SDL_EnableUNICODE(1);
    }

    boost::shared_ptr<Window> SDLGfxDriver::createWindow(int width, int height,
                                                         bool resizable, bool fullscreen,
                                                         const std::string &title)
    {
        if (g_sdl_window.lock()) {
            throw CoercriError("SDL 1 only supports one window at a time");
        }

        if (fullscreen) {
            width = desktop_width;
            height = desktop_height;
        }
        
        g_sdl_required_flags = SDL_ANYFORMAT | SDL_HWSURFACE | SDL_DOUBLEBUF;
        if (fullscreen) g_sdl_required_flags |= SDL_FULLSCREEN;
        if (resizable) g_sdl_required_flags |= SDL_RESIZABLE;

        // In windowed mode we call SetVideoMode twice. This is a workaround for a bug when SDL is used with xmonad.
        SDL_Surface * sdl_surf = SDL_SetVideoMode(width, height, 0, g_sdl_required_flags);
        if (!fullscreen) sdl_surf = SDL_SetVideoMode(width, height, 0, g_sdl_required_flags);

        if (!sdl_surf) {
            throw CoercriError("SDL_SetVideoMode failed");
        }
        
        SDL_WM_SetCaption(title.c_str(), title.c_str());

        SDL_EnableUNICODE(1);
        SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
        
        boost::shared_ptr<SDLWindow> result(new SDLWindow(desktop_width, desktop_height));
        g_sdl_window = result;
        return result;
    }

    boost::shared_ptr<Graphic> SDLGfxDriver::createGraphic(boost::shared_ptr<const PixelArray> pixels, int hx, int hy)
    {
        return boost::shared_ptr<Graphic>(new SDLGraphic(pixels, hx, hy));
    }

    bool SDLGfxDriver::pollEvents()
    {
        boost::shared_ptr<SDLWindow> window(g_sdl_window.lock());
        if (window && window->need_window_resize) {
            // process this first.
            int w,h;
            window->getSize(w,h);
            window->forEachListener(OnResize(w, h));
            window->need_window_resize = false;
            return true;
        }
        
        SDL_Event event;
        if (SDL_PollEvent(&event)) {
            DoEvent(event, surrogate_pair_start);
            return true;
        } else {
            return false;
        }
    }
}
