/*
 * FILE:
 *   sdl_gfx_driver.cpp
 *
 * AUTHOR:
 *   Stephen Thompson <stephen@solarflare.org.uk>
 *
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2025.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0, 
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "sdl_gfx_context.hpp"
#include "sdl_gfx_driver.hpp"
#include "sdl_graphic.hpp"
#include "sdl_window.hpp"
#include "../../core/coercri_error.hpp"
#include "../../gfx/mouse_button.hpp"
#include "../../gfx/rectangle.hpp"
#include "../../gfx/region.hpp"
#include "../../gfx/window_listener_funcs.hpp"

#include "boost/weak_ptr.hpp"
#include <map>
#include <iostream>

#include <SDL2/SDL.h>

namespace Coercri {

    namespace {

        // Key to scancode conversions
        std::map<SDL_Scancode, std::string> g_keytable;
        std::map<std::string, SDL_Scancode> g_reverse_keytable;

        void InitKeyTable()
        {
            if (!g_keytable.empty()) return;  // already initialized

            g_keytable[SDL_SCANCODE_A] = "a";
            g_keytable[SDL_SCANCODE_B] = "b";
            g_keytable[SDL_SCANCODE_C] = "c";
            g_keytable[SDL_SCANCODE_D] = "d";
            g_keytable[SDL_SCANCODE_E] = "e";
            g_keytable[SDL_SCANCODE_F] = "f";
            g_keytable[SDL_SCANCODE_G] = "g";
            g_keytable[SDL_SCANCODE_H] = "h";
            g_keytable[SDL_SCANCODE_I] = "i";
            g_keytable[SDL_SCANCODE_J] = "j";
            g_keytable[SDL_SCANCODE_K] = "k";
            g_keytable[SDL_SCANCODE_L] = "l";
            g_keytable[SDL_SCANCODE_M] = "m";
            g_keytable[SDL_SCANCODE_N] = "n";
            g_keytable[SDL_SCANCODE_O] = "o";
            g_keytable[SDL_SCANCODE_P] = "p";
            g_keytable[SDL_SCANCODE_Q] = "q";
            g_keytable[SDL_SCANCODE_R] = "r";
            g_keytable[SDL_SCANCODE_S] = "s";
            g_keytable[SDL_SCANCODE_T] = "t";
            g_keytable[SDL_SCANCODE_U] = "u";
            g_keytable[SDL_SCANCODE_V] = "v";
            g_keytable[SDL_SCANCODE_W] = "w";
            g_keytable[SDL_SCANCODE_X] = "x";
            g_keytable[SDL_SCANCODE_Y] = "y";
            g_keytable[SDL_SCANCODE_Z] = "z";

            g_keytable[SDL_SCANCODE_1] = "1";
            g_keytable[SDL_SCANCODE_2] = "2";
            g_keytable[SDL_SCANCODE_3] = "3";
            g_keytable[SDL_SCANCODE_4] = "4";
            g_keytable[SDL_SCANCODE_5] = "5";
            g_keytable[SDL_SCANCODE_6] = "6";
            g_keytable[SDL_SCANCODE_7] = "7";
            g_keytable[SDL_SCANCODE_8] = "8";
            g_keytable[SDL_SCANCODE_9] = "9";
            g_keytable[SDL_SCANCODE_0] = "0";

            g_keytable[SDL_SCANCODE_RETURN] = "return";
            g_keytable[SDL_SCANCODE_ESCAPE] = "escape";
            g_keytable[SDL_SCANCODE_BACKSPACE] = "backspace";
            g_keytable[SDL_SCANCODE_TAB] = "tab";
            g_keytable[SDL_SCANCODE_SPACE] = "space";

            g_keytable[SDL_SCANCODE_MINUS] = "minus";
            g_keytable[SDL_SCANCODE_EQUALS] = "equals";
            g_keytable[SDL_SCANCODE_LEFTBRACKET] = "left_bracket";
            g_keytable[SDL_SCANCODE_RIGHTBRACKET] = "right_bracket";
            g_keytable[SDL_SCANCODE_BACKSLASH] = "backslash";
            g_keytable[SDL_SCANCODE_NONUSHASH] = "backslash";  // SDL_SCANCODE_NONUSHASH is almost never generated by SDL, and anyway should be considered identical to SDL_SCANCODE_BACKSLASH

            g_keytable[SDL_SCANCODE_SEMICOLON] = "semicolon";
            g_keytable[SDL_SCANCODE_APOSTROPHE] = "single_quote";
            g_keytable[SDL_SCANCODE_GRAVE] = "backquote";
            g_keytable[SDL_SCANCODE_COMMA] = "comma";
            g_keytable[SDL_SCANCODE_PERIOD] = "period";
            g_keytable[SDL_SCANCODE_SLASH] = "slash";

            g_keytable[SDL_SCANCODE_CAPSLOCK] = "caps_lock";

            g_keytable[SDL_SCANCODE_F1] = "f1";
            g_keytable[SDL_SCANCODE_F2] = "f2";
            g_keytable[SDL_SCANCODE_F3] = "f3";
            g_keytable[SDL_SCANCODE_F4] = "f4";
            g_keytable[SDL_SCANCODE_F5] = "f5";
            g_keytable[SDL_SCANCODE_F6] = "f6";
            g_keytable[SDL_SCANCODE_F7] = "f7";
            g_keytable[SDL_SCANCODE_F8] = "f8";
            g_keytable[SDL_SCANCODE_F9] = "f9";
            g_keytable[SDL_SCANCODE_F10] = "f10";
            g_keytable[SDL_SCANCODE_F11] = "f11";
            g_keytable[SDL_SCANCODE_F12] = "f12";

            g_keytable[SDL_SCANCODE_PRINTSCREEN] = "print_screen";
            g_keytable[SDL_SCANCODE_SCROLLLOCK] = "scroll_lock";
            g_keytable[SDL_SCANCODE_PAUSE] = "pause";
            g_keytable[SDL_SCANCODE_INSERT] = "insert";

            g_keytable[SDL_SCANCODE_HOME] = "home";
            g_keytable[SDL_SCANCODE_PAGEUP] = "page_up";
            g_keytable[SDL_SCANCODE_DELETE] = "delete";
            g_keytable[SDL_SCANCODE_END] = "end";
            g_keytable[SDL_SCANCODE_PAGEDOWN] = "page_down";
            g_keytable[SDL_SCANCODE_RIGHT] = "right";
            g_keytable[SDL_SCANCODE_LEFT] = "left";
            g_keytable[SDL_SCANCODE_DOWN] = "down";
            g_keytable[SDL_SCANCODE_UP] = "up";

            g_keytable[SDL_SCANCODE_NUMLOCKCLEAR] = "num_lock";

            g_keytable[SDL_SCANCODE_KP_DIVIDE] = "kp_divide";
            g_keytable[SDL_SCANCODE_KP_MULTIPLY] = "kp_multiply";
            g_keytable[SDL_SCANCODE_KP_MINUS] = "kp_minus";
            g_keytable[SDL_SCANCODE_KP_PLUS] = "kp_plus";
            g_keytable[SDL_SCANCODE_KP_ENTER] = "kp_enter";
            g_keytable[SDL_SCANCODE_KP_1] = "kp_1";
            g_keytable[SDL_SCANCODE_KP_2] = "kp_2";
            g_keytable[SDL_SCANCODE_KP_3] = "kp_3";
            g_keytable[SDL_SCANCODE_KP_4] = "kp_4";
            g_keytable[SDL_SCANCODE_KP_5] = "kp_5";
            g_keytable[SDL_SCANCODE_KP_6] = "kp_6";
            g_keytable[SDL_SCANCODE_KP_7] = "kp_7";
            g_keytable[SDL_SCANCODE_KP_8] = "kp_8";
            g_keytable[SDL_SCANCODE_KP_9] = "kp_9";
            g_keytable[SDL_SCANCODE_KP_0] = "kp_0";
            g_keytable[SDL_SCANCODE_KP_PERIOD] = "kp_period";

            g_keytable[SDL_SCANCODE_NONUSBACKSLASH] = "non_us_backslash";

            g_keytable[SDL_SCANCODE_APPLICATION] = "menu";  // we don't distinguish between this and SDL_SCANCODE_MENU (which is very rare anyway)
            g_keytable[SDL_SCANCODE_POWER] = "power";
            g_keytable[SDL_SCANCODE_KP_EQUALS] = "kp_equals";
            g_keytable[SDL_SCANCODE_F13] = "f13";
            g_keytable[SDL_SCANCODE_F14] = "f14";
            g_keytable[SDL_SCANCODE_F15] = "f15";
            g_keytable[SDL_SCANCODE_F16] = "f16";
            g_keytable[SDL_SCANCODE_F17] = "f17";
            g_keytable[SDL_SCANCODE_F18] = "f18";
            g_keytable[SDL_SCANCODE_F19] = "f19";
            g_keytable[SDL_SCANCODE_F20] = "f20";
            g_keytable[SDL_SCANCODE_F21] = "f21";
            g_keytable[SDL_SCANCODE_F22] = "f22";
            g_keytable[SDL_SCANCODE_F23] = "f23";
            g_keytable[SDL_SCANCODE_F24] = "f24";
            g_keytable[SDL_SCANCODE_EXECUTE] = "execute";
            g_keytable[SDL_SCANCODE_HELP] = "help";
            g_keytable[SDL_SCANCODE_MENU] = "menu";
            g_keytable[SDL_SCANCODE_SELECT] = "select";
            g_keytable[SDL_SCANCODE_STOP] = "stop";
            g_keytable[SDL_SCANCODE_AGAIN] = "again";
            g_keytable[SDL_SCANCODE_UNDO] = "undo";
            g_keytable[SDL_SCANCODE_CUT] = "cut";
            g_keytable[SDL_SCANCODE_COPY] = "copy";
            g_keytable[SDL_SCANCODE_PASTE] = "paste";
            g_keytable[SDL_SCANCODE_FIND] = "find";
            g_keytable[SDL_SCANCODE_MUTE] = "mute";
            g_keytable[SDL_SCANCODE_VOLUMEUP] = "volume_up";
            g_keytable[SDL_SCANCODE_VOLUMEDOWN] = "volume_down";

            g_keytable[SDL_SCANCODE_KP_COMMA] = "kp_comma";
            g_keytable[SDL_SCANCODE_KP_EQUALSAS400] = "kp_equals";

            g_keytable[SDL_SCANCODE_INTERNATIONAL1] = "international_1";
            g_keytable[SDL_SCANCODE_INTERNATIONAL2] = "international_2";
            g_keytable[SDL_SCANCODE_INTERNATIONAL3] = "international_3";
            g_keytable[SDL_SCANCODE_INTERNATIONAL4] = "international_4";
            g_keytable[SDL_SCANCODE_INTERNATIONAL5] = "international_5";
            g_keytable[SDL_SCANCODE_INTERNATIONAL6] = "international_6";
            g_keytable[SDL_SCANCODE_INTERNATIONAL7] = "international_7";
            g_keytable[SDL_SCANCODE_INTERNATIONAL8] = "international_8";
            g_keytable[SDL_SCANCODE_INTERNATIONAL9] = "international_9";

            g_keytable[SDL_SCANCODE_LANG1] = "lang_1";
            g_keytable[SDL_SCANCODE_LANG2] = "lang_2";
            g_keytable[SDL_SCANCODE_LANG3] = "lang_3";
            g_keytable[SDL_SCANCODE_LANG4] = "lang_4";
            g_keytable[SDL_SCANCODE_LANG5] = "lang_5";
            g_keytable[SDL_SCANCODE_LANG6] = "lang_6";
            g_keytable[SDL_SCANCODE_LANG7] = "lang_7";
            g_keytable[SDL_SCANCODE_LANG8] = "lang_8";
            g_keytable[SDL_SCANCODE_LANG9] = "lang_9";

            g_keytable[SDL_SCANCODE_ALTERASE] = "alt_erase";
            g_keytable[SDL_SCANCODE_SYSREQ] = "sys_req";
            g_keytable[SDL_SCANCODE_CANCEL] = "cancel";
            g_keytable[SDL_SCANCODE_CLEAR] = "clear";
            g_keytable[SDL_SCANCODE_PRIOR] = "prior";
            g_keytable[SDL_SCANCODE_RETURN2] = "return2";
            g_keytable[SDL_SCANCODE_SEPARATOR] = "separator";
            g_keytable[SDL_SCANCODE_OUT] = "out";
            g_keytable[SDL_SCANCODE_OPER] = "oper";
            g_keytable[SDL_SCANCODE_CLEARAGAIN] = "clear_again";
            g_keytable[SDL_SCANCODE_CRSEL] = "crsel";
            g_keytable[SDL_SCANCODE_EXSEL] = "exsel";

            g_keytable[SDL_SCANCODE_KP_00] = "kp_00";
            g_keytable[SDL_SCANCODE_KP_000] = "kp_000";
            g_keytable[SDL_SCANCODE_THOUSANDSSEPARATOR] = "thousands_separator";
            g_keytable[SDL_SCANCODE_DECIMALSEPARATOR] = "decimal_separator";
            g_keytable[SDL_SCANCODE_CURRENCYUNIT] = "currency_unit";
            g_keytable[SDL_SCANCODE_CURRENCYSUBUNIT] = "currency_subunit";
            g_keytable[SDL_SCANCODE_KP_LEFTPAREN] = "kp_left_paren";
            g_keytable[SDL_SCANCODE_KP_RIGHTPAREN] = "kp_right_paren";
            g_keytable[SDL_SCANCODE_KP_LEFTBRACE] = "kp_left_brace";
            g_keytable[SDL_SCANCODE_KP_RIGHTBRACE] = "kp_right_brace";
            g_keytable[SDL_SCANCODE_KP_TAB] = "kp_tab";
            g_keytable[SDL_SCANCODE_KP_BACKSPACE] = "kp_backspace";
            g_keytable[SDL_SCANCODE_KP_A] = "kp_a";
            g_keytable[SDL_SCANCODE_KP_B] = "kp_b";
            g_keytable[SDL_SCANCODE_KP_C] = "kp_c";
            g_keytable[SDL_SCANCODE_KP_D] = "kp_d";
            g_keytable[SDL_SCANCODE_KP_E] = "kp_e";
            g_keytable[SDL_SCANCODE_KP_F] = "kp_f";
            g_keytable[SDL_SCANCODE_KP_XOR] = "kp_xor";
            g_keytable[SDL_SCANCODE_KP_POWER] = "kp_power";
            g_keytable[SDL_SCANCODE_KP_PERCENT] = "kp_percent";
            g_keytable[SDL_SCANCODE_KP_LESS] = "kp_less";
            g_keytable[SDL_SCANCODE_KP_GREATER] = "kp_greater";
            g_keytable[SDL_SCANCODE_KP_AMPERSAND] = "kp_ampersand";
            g_keytable[SDL_SCANCODE_KP_DBLAMPERSAND] = "kp_double_ampersand";
            g_keytable[SDL_SCANCODE_KP_VERTICALBAR] = "kp_vertical_bar";
            g_keytable[SDL_SCANCODE_KP_DBLVERTICALBAR] = "kp_double_vertical_bar";
            g_keytable[SDL_SCANCODE_KP_COLON] = "kp_colon";
            g_keytable[SDL_SCANCODE_KP_HASH] = "kp_hash";
            g_keytable[SDL_SCANCODE_KP_SPACE] = "kp_space";
            g_keytable[SDL_SCANCODE_KP_AT] = "kp_at";
            g_keytable[SDL_SCANCODE_KP_EXCLAM] = "kp_exclam";
            g_keytable[SDL_SCANCODE_KP_MEMSTORE] = "kp_mem_store";
            g_keytable[SDL_SCANCODE_KP_MEMRECALL] = "kp_mem_recall";
            g_keytable[SDL_SCANCODE_KP_MEMCLEAR] = "kp_mem_clear";
            g_keytable[SDL_SCANCODE_KP_MEMADD] = "kp_mem_add";
            g_keytable[SDL_SCANCODE_KP_MEMSUBTRACT] = "kp_mem_subtract";
            g_keytable[SDL_SCANCODE_KP_MEMMULTIPLY] = "kp_mem_multiply";
            g_keytable[SDL_SCANCODE_KP_MEMDIVIDE] = "kp_mem_divide";
            g_keytable[SDL_SCANCODE_KP_PLUSMINUS] = "kp_plus_minus";
            g_keytable[SDL_SCANCODE_KP_CLEAR] = "kp_clear";
            g_keytable[SDL_SCANCODE_KP_CLEARENTRY] = "kp_clear_entry";
            g_keytable[SDL_SCANCODE_KP_BINARY] = "kp_binary";
            g_keytable[SDL_SCANCODE_KP_OCTAL] = "kp_octal";
            g_keytable[SDL_SCANCODE_KP_DECIMAL] = "kp_decimal";
            g_keytable[SDL_SCANCODE_KP_HEXADECIMAL] = "kp_hexadecimal";

            g_keytable[SDL_SCANCODE_LCTRL] = "left_control";
            g_keytable[SDL_SCANCODE_LSHIFT] = "left_shift";
            g_keytable[SDL_SCANCODE_LALT] = "left_alt";
            g_keytable[SDL_SCANCODE_LGUI] = "left_windows";
            g_keytable[SDL_SCANCODE_RCTRL] = "right_control";
            g_keytable[SDL_SCANCODE_RSHIFT] = "right_shift";
            g_keytable[SDL_SCANCODE_RALT] = "right_alt";
            g_keytable[SDL_SCANCODE_RGUI] = "right_windows";
            g_keytable[SDL_SCANCODE_MODE] = "mode";

            g_keytable[SDL_SCANCODE_AUDIONEXT] = "audio_next";
            g_keytable[SDL_SCANCODE_AUDIOPREV] = "audio_prev";
            g_keytable[SDL_SCANCODE_AUDIOSTOP] = "audio_stop";
            g_keytable[SDL_SCANCODE_AUDIOPLAY] = "audio_play";
            g_keytable[SDL_SCANCODE_AUDIOMUTE] = "audio_mute";

            g_keytable[SDL_SCANCODE_MEDIASELECT] = "media_select";
            g_keytable[SDL_SCANCODE_WWW] = "www";
            g_keytable[SDL_SCANCODE_MAIL] = "mail";
            g_keytable[SDL_SCANCODE_CALCULATOR] = "calculator";
            g_keytable[SDL_SCANCODE_COMPUTER] = "computer";
            g_keytable[SDL_SCANCODE_AC_SEARCH] = "ac_search";
            g_keytable[SDL_SCANCODE_AC_HOME] = "ac_home";
            g_keytable[SDL_SCANCODE_AC_BACK] = "ac_back";
            g_keytable[SDL_SCANCODE_AC_FORWARD] = "ac_forward";
            g_keytable[SDL_SCANCODE_AC_STOP] = "ac_stop";
            g_keytable[SDL_SCANCODE_AC_REFRESH] = "ac_refresh";
            g_keytable[SDL_SCANCODE_AC_BOOKMARKS] = "ac_bookmarks";

            // Note: We skip the so-called "Walther keys" since it seems these were removed in SDL3 anyway

            g_keytable[SDL_SCANCODE_AUDIOREWIND] = "audio_rewind";
            g_keytable[SDL_SCANCODE_AUDIOFASTFORWARD] = "audio_fast_forward";

            // The following are recent additions i.e. they don't
            // exist in older SDL2 versions. Perhaps they can be
            // uncommented in a few years once everyone has upgraded.
            // On the other hand, these are very rare/obscure keys so
            // probably no-one will care about them anyway!
            //g_keytable[SDL_SCANCODE_SOFTLEFT] = "soft_left";
            //g_keytable[SDL_SCANCODE_SOFTRIGHT] = "soft_right";
            //g_keytable[SDL_SCANCODE_CALL] = "call";
            //g_keytable[SDL_SCANCODE_ENDCALL] = "end_call";


            // Now create the reverse mapping
            for (const auto & item : g_keytable) {
                SDL_Scancode scancode_in = item.first;
                const std::string &name_in = item.second;
                SDL_Scancode & scancode_out = g_reverse_keytable[name_in];
                // Keep the lowest scancode_in corresponding to each
                // name_in. (This seems to work well.)
                if (scancode_out == 0     // not set yet
                || scancode_in < scancode_out) {   // we found a "better" scancode
                    scancode_out = scancode_in;
                }
            }
        }

        int GetModifiers(unsigned int sdl_mod)
        {
            int result = 0;
            if (sdl_mod & KMOD_ALT) result += KM_ALT;
            if (sdl_mod & KMOD_CTRL) result += KM_CONTROL;
            if (sdl_mod & KMOD_SHIFT) result += KM_SHIFT;
            return result;
        }

        MouseButton MouseButtonFromSDL(int m, bool &error)
        {
            switch (m) {
            case SDL_BUTTON_LEFT: return MB_LEFT;
            case SDL_BUTTON_RIGHT: return MB_RIGHT;
            case SDL_BUTTON_MIDDLE: return MB_MIDDLE;
            default: error = true; return MB_LEFT;
            }
        }

        //
        // Handle SDL events.
        //

        void DoEvent(SDLWindow *focus_window, const SDL_Event &event)
        {
            switch (event.type) {
            case SDL_QUIT:
                if (focus_window) {
                    focus_window->forEachListener(OnClose());
                }
                break;

            case SDL_WINDOWEVENT:
                {
                    SDL_Window *sdl_window = SDL_GetWindowFromID(event.window.windowID);
                    if (sdl_window) {
                        SDLWindow *window = static_cast<SDLWindow*>(SDL_GetWindowData(sdl_window, "coercri"));
                        switch (event.window.event) {
                        case SDL_WINDOWEVENT_EXPOSED:
                            {
                                // Invalidate the entire screen (I don't think SDL
                                // gives more detailed info about the invalid
                                // rectangle?)
                                int w, h;
                                SDL_GetWindowSize(sdl_window, &w, &h);
                                Rectangle rectangle(0, 0, w, h);
                                window->invalidateRectangle(rectangle);
                            }
                            break;

                        case SDL_WINDOWEVENT_FOCUS_GAINED:
                            window->forEachListener(OnGainFocus());
                            break;

                        case SDL_WINDOWEVENT_FOCUS_LOST:
                            window->forEachListener(OnLoseFocus());
                            break;

                        case SDL_WINDOWEVENT_SHOWN:
                        case SDL_WINDOWEVENT_HIDDEN:
                        case SDL_WINDOWEVENT_MINIMIZED:
                        case SDL_WINDOWEVENT_MAXIMIZED:
                        case SDL_WINDOWEVENT_RESTORED:
                        {
                            bool old_hidden = window->hidden_flag;
                            bool old_minimized = window->minimized_flag;

                            switch (event.window.event) {
                            case SDL_WINDOWEVENT_HIDDEN: window->hidden_flag = true; break;
                            case SDL_WINDOWEVENT_SHOWN: window->hidden_flag = false; break;
                            case SDL_WINDOWEVENT_MINIMIZED: window->minimized_flag = true; break;
                            default: window->minimized_flag = false; break;
                            }

                            bool old_min = old_hidden || old_minimized;
                            bool new_min = window->hidden_flag || window->minimized_flag;

                            if (new_min && !old_min) window->forEachListener(OnMinimize());
                            if (!new_min && old_min) window->forEachListener(OnUnminimize());

                            break;
                        }

                        case SDL_WINDOWEVENT_SIZE_CHANGED:
                            window->forEachListener(OnResize(event.window.data1, event.window.data2));
                            break;
                        }
                    }
                }
                break;

            case SDL_KEYDOWN:
            case SDL_KEYUP:
                if (focus_window) {
                    // Convert to a Coercri::Scancode
                    SDL_Scancode scancode_num = event.key.keysym.scancode;
                    auto key_it = g_keytable.find(scancode_num);

                    Scancode scancode;
                    if (key_it == g_keytable.end()) {
                        // Didn't find it. Give it a name like "sdl_scancode_12345"
                        scancode = Scancode("sdl_scancode_" + std::to_string(scancode_num));
                    } else {
                        // Use our standardized name from the lookup table
                        scancode = Scancode(key_it->second);
                    }

                    // Find out what kind of key event this is.
                    KeyEventType type;
                    if (event.type == SDL_KEYDOWN) {
                        if (event.key.repeat) {
                            type = KEY_AUTO_REPEAT;
                        } else {
                            type = KEY_PRESSED;
                        }
                    } else {
                        type = KEY_RELEASED;
                    }
                    
                    // Find the modifiers.
                    const int modifiers = GetModifiers(event.key.keysym.mod);

                    // Send the key event.
                    focus_window->forEachListener(OnKey(type, scancode, KeyModifier(modifiers)));
                }
                break;

            case SDL_TEXTINPUT:
                {
                    OnTextInput oti;
                    oti.str = UTF8String::fromUTF8Safe(event.text.text);
                    if (focus_window) focus_window->forEachListener(oti);
                }
                break;

            case SDL_MOUSEBUTTONDOWN:
                {
                    bool err = false;
                    const MouseButton mb = MouseButtonFromSDL(event.button.button, err);
                    if (!err && focus_window) {
                        focus_window->forEachListener(OnMouseDown(event.button.x, event.button.y, mb));
                    }
                }
                break;

            case SDL_MOUSEBUTTONUP:
                {
                    bool err = false;
                    const MouseButton mb = MouseButtonFromSDL(event.button.button, err);
                    if (!err && focus_window) {
                        focus_window->forEachListener(OnMouseUp(event.button.x, event.button.y, mb));
                    }
                }
                break;

            case SDL_MOUSEMOTION:
                if (focus_window) {
                    focus_window->forEachListener(OnMouseMove(event.motion.x, event.motion.y));
                }
                break;

            case SDL_MOUSEWHEEL:
                if (focus_window) {
                    int dy = event.wheel.y;
                    if (event.wheel.direction == SDL_MOUSEWHEEL_FLIPPED) {
                        dy = -dy;
                    }
                    const MouseButton mb = dy > 0 ? MB_WHEEL_UP : MB_WHEEL_DOWN;

                    // note: can't use event.wheel.mouseX/Y here,
                    // because not all linux distributions will have
                    // SDL 2.26 or later yet.
                    int x, y;
                    SDL_GetMouseState(&x, &y);

                    focus_window->forEachListener(OnMouseDown(x, y, mb));
                    focus_window->forEachListener(OnMouseUp(x, y, mb));
                }
                break;
            }
        }

        SDLWindow * FindCurrentWindow(const std::vector<boost::weak_ptr<SDLWindow> > & windows)
        {
            // Look for a window with current keyboard or mouse focus; we will send the
            // event to this window.
            // TODO: We should probably distinguish between keyboard and mouse events and
            // look for the appropriate focus type?
            SDL_Window * sdl_win = SDL_GetKeyboardFocus();
            if (!sdl_win) {
                sdl_win = SDL_GetMouseFocus();
            }

            if (sdl_win) {
                return static_cast<SDLWindow*>(SDL_GetWindowData(sdl_win, "coercri"));
            }

            // If no window currently has focus then just return the first valid window in
            // our list of windows, if possible.
            for (auto it = windows.begin(); it != windows.end(); ++it) {
                boost::shared_ptr<SDLWindow> win = it->lock();
                if (win) {
                    return win.get();
                }
            }

            // As a last resort, return null. (This will drop the event.)
            return nullptr;
        }

    } // namespace


    // Helper called by sdl_window.cpp
    SDL_Scancode ScancodeReverseLookup(const std::string &name)
    {
        constexpr std::string_view prefix = "sdl_scancode_";
        if (name.starts_with(prefix)) {
            long int i = std::strtol(name.c_str() + prefix.size(), nullptr, 10);
            if (i > 0 && i < SDL_NUM_SCANCODES) {
                return SDL_Scancode(i);
            }
        } else {
            auto it = g_reverse_keytable.find(name);
            if (it != g_reverse_keytable.end()) {
                return it->second;
            }
        }
        return SDL_SCANCODE_UNKNOWN;
    }
    

    //
    // SDLGfxDriver implementation
    //
    
    SDLGfxDriver::SDLGfxDriver()
        : video_subsystem(SDL_INIT_VIDEO)
    {
        InitKeyTable();
    }

    boost::shared_ptr<Window> SDLGfxDriver::createWindow(const WindowParams &params)
    {
        int width = params.width;
        int height = params.height;

        if (params.fullscreen) {
            SDL_DisplayMode mode;
            int err = SDL_GetDesktopDisplayMode(0, &mode);
            if (err) {
                width = height = 600;
            } else {
                width = mode.w;
                height = mode.h;
            }
        }

        Uint32 flags = 0;
        if (params.fullscreen) flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;
        if (params.resizable) flags |= SDL_WINDOW_RESIZABLE;
        if (params.maximized) flags |= SDL_WINDOW_MAXIMIZED;

        SDL_Window *sdl_window = SDL_CreateWindow(params.title.asUTF8().c_str(),
                                                  SDL_WINDOWPOS_UNDEFINED,
                                                  SDL_WINDOWPOS_UNDEFINED,
                                                  width,
                                                  height,
                                                  flags);

        if (sdl_window == NULL) {
            throw CoercriError("SDL_CreateWindow failed");
        }

        boost::shared_ptr<SDLWindow> result(new SDLWindow(sdl_window, params.vsync));
        windows.push_back(boost::weak_ptr<SDLWindow>(result));
        return result;
    }

    boost::shared_ptr<Graphic> SDLGfxDriver::createGraphic(PixelArray &&pixels, int hx, int hy, GraphicFlags flags)
    {
        return boost::shared_ptr<Graphic>(new SDLGraphic(std::move(pixels), hx, hy, flags));
    }

    bool SDLGfxDriver::pollEvents()
    {
        return waitEventMsec(0);
    }

    bool SDLGfxDriver::waitEventMsec(int ms)
    {
        // Remove expired weak ptrs from this->windows
        for (auto iter = windows.begin(); iter != windows.end(); ) {
            if (iter->expired()) {
                windows.erase(iter);
            } else {
                ++iter;
            }
        }

        // Check for windows that need resizing
        for (auto iter = windows.begin(); iter != windows.end(); ++iter) {
            boost::shared_ptr<SDLWindow> window = iter->lock();
            if (window && window->need_window_resize) {
                // process this first.
                int w,h;
                window->getSize(w,h);
                window->forEachListener(OnResize(w, h));
                window->need_window_resize = false;
                return true;
            }
        }

        // Check for an SDL event
        SDL_Event event;
        bool got_event;

        if (ms > 0) {
            got_event = SDL_WaitEventTimeout(&event, ms);
        } else {
            got_event = SDL_PollEvent(&event);
        }

        if (got_event) {
            SDLWindow *win = FindCurrentWindow(windows);
            DoEvent(win, event);
            return true;
        } else {
            return false;
        }
    }

    std::vector<Scancode> SDLGfxDriver::getKnownScancodes()
    {
        std::vector<Scancode> result;
        result.reserve(g_reverse_keytable.size());
        for (const auto &item : g_reverse_keytable) {
            result.push_back(Scancode(item.first));
        }
        return result;
    }
}
