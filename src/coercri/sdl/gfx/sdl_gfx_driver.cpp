/*
 * FILE:
 *   sdl_gfx_driver.cpp
 *
 * AUTHOR:
 *   Stephen Thompson <stephen@solarflare.org.uk>
 *
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2014.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0, 
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "sdl_gfx_context.hpp"
#include "sdl_gfx_driver.hpp"
#include "sdl_graphic.hpp"
#include "sdl_window.hpp"
#include "../../core/coercri_error.hpp"
#include "../../gfx/mouse_button.hpp"
#include "../../gfx/rectangle.hpp"
#include "../../gfx/region.hpp"
#include "../../gfx/window_listener_funcs.hpp"

#include "boost/weak_ptr.hpp"
#include <map>

#include <SDL2/SDL.h>

namespace Coercri {

    namespace {

        // Global key tables
        std::map<SDL_Keycode, KeyCode> g_keytable;

        void InitKeyTable()
        {
            if (!g_keytable.empty()) return;  // already initialized

            g_keytable[SDLK_BACKSPACE] = KC_BACKSPACE;
            g_keytable[SDLK_TAB] = KC_TAB;
            g_keytable[SDLK_CLEAR] = KC_CLEAR;
            g_keytable[SDLK_RETURN] = KC_RETURN;
            g_keytable[SDLK_PAUSE] = KC_PAUSE;
            g_keytable[SDLK_ESCAPE] = KC_ESCAPE;
            g_keytable[SDLK_SPACE] = KC_SPACE;
            g_keytable[SDLK_EXCLAIM] = KC_EXCLAIM;
            g_keytable[SDLK_QUOTEDBL] = KC_DOUBLE_QUOTE;
            g_keytable[SDLK_HASH] = KC_HASH;
            g_keytable[SDLK_DOLLAR] = KC_DOLLAR;
            g_keytable[SDLK_AMPERSAND] = KC_AMPERSAND;
            g_keytable[SDLK_QUOTE] = KC_SINGLE_QUOTE;
            g_keytable[SDLK_LEFTPAREN] = KC_LEFT_PAREN;
            g_keytable[SDLK_RIGHTPAREN] = KC_RIGHT_PAREN;
            g_keytable[SDLK_ASTERISK] = KC_ASTERISK;
            g_keytable[SDLK_PLUS] = KC_PLUS;
            g_keytable[SDLK_COMMA] = KC_COMMA;
            g_keytable[SDLK_MINUS] = KC_MINUS;
            g_keytable[SDLK_PERIOD] = KC_PERIOD;
            g_keytable[SDLK_SLASH] = KC_SLASH;
            g_keytable[SDLK_0] = KC_0;
            g_keytable[SDLK_1] = KC_1;
            g_keytable[SDLK_2] = KC_2;
            g_keytable[SDLK_3] = KC_3;
            g_keytable[SDLK_4] = KC_4;
            g_keytable[SDLK_5] = KC_5;
            g_keytable[SDLK_6] = KC_6;
            g_keytable[SDLK_7] = KC_7;
            g_keytable[SDLK_8] = KC_8;
            g_keytable[SDLK_9] = KC_9;
            g_keytable[SDLK_COLON] = KC_COLON;
            g_keytable[SDLK_SEMICOLON] = KC_SEMICOLON;
            g_keytable[SDLK_LESS] = KC_LESS;
            g_keytable[SDLK_EQUALS] = KC_EQUALS;
            g_keytable[SDLK_GREATER] = KC_GREATER;
            g_keytable[SDLK_QUESTION] = KC_QUESTION;
            g_keytable[SDLK_AT] = KC_AT;
            g_keytable[SDLK_LEFTBRACKET] = KC_LEFT_BRACKET;
            g_keytable[SDLK_BACKSLASH] = KC_BACKSLASH;
            g_keytable[SDLK_RIGHTBRACKET] = KC_RIGHT_BRACKET;
            g_keytable[SDLK_CARET] = KC_CARET;
            g_keytable[SDLK_UNDERSCORE] = KC_UNDERSCORE;
            g_keytable[SDLK_BACKQUOTE] = KC_BACKQUOTE;
            g_keytable[SDLK_a] = KC_A;
            g_keytable[SDLK_b] = KC_B;
            g_keytable[SDLK_c] = KC_C;
            g_keytable[SDLK_d] = KC_D;
            g_keytable[SDLK_e] = KC_E;
            g_keytable[SDLK_f] = KC_F;
            g_keytable[SDLK_g] = KC_G;
            g_keytable[SDLK_h] = KC_H;
            g_keytable[SDLK_i] = KC_I;
            g_keytable[SDLK_j] = KC_J;
            g_keytable[SDLK_k] = KC_K;
            g_keytable[SDLK_l] = KC_L;
            g_keytable[SDLK_m] = KC_M;
            g_keytable[SDLK_n] = KC_N;
            g_keytable[SDLK_o] = KC_O;
            g_keytable[SDLK_p] = KC_P;
            g_keytable[SDLK_q] = KC_Q;
            g_keytable[SDLK_r] = KC_R;
            g_keytable[SDLK_s] = KC_S;
            g_keytable[SDLK_t] = KC_T;
            g_keytable[SDLK_u] = KC_U;
            g_keytable[SDLK_v] = KC_V;
            g_keytable[SDLK_w] = KC_W;
            g_keytable[SDLK_x] = KC_X;
            g_keytable[SDLK_y] = KC_Y;
            g_keytable[SDLK_z] = KC_Z;
            g_keytable[SDLK_DELETE] = KC_DELETE;
            g_keytable[SDLK_KP_0] = KC_KP_0;
            g_keytable[SDLK_KP_1] = KC_KP_1;
            g_keytable[SDLK_KP_2] = KC_KP_2;
            g_keytable[SDLK_KP_3] = KC_KP_3;
            g_keytable[SDLK_KP_4] = KC_KP_4;
            g_keytable[SDLK_KP_5] = KC_KP_5;
            g_keytable[SDLK_KP_6] = KC_KP_6;
            g_keytable[SDLK_KP_7] = KC_KP_7;
            g_keytable[SDLK_KP_8] = KC_KP_8;
            g_keytable[SDLK_KP_9] = KC_KP_9;
            g_keytable[SDLK_KP_PERIOD] = KC_KP_PERIOD;
            g_keytable[SDLK_KP_DIVIDE] = KC_KP_DIVIDE;
            g_keytable[SDLK_KP_MULTIPLY] = KC_KP_MULTIPLY;
            g_keytable[SDLK_KP_MINUS] = KC_KP_MINUS;
            g_keytable[SDLK_KP_PLUS] = KC_KP_PLUS;
            g_keytable[SDLK_KP_ENTER] = KC_KP_ENTER;
            g_keytable[SDLK_KP_EQUALS] = KC_KP_EQUALS;
            g_keytable[SDLK_UP] = KC_UP;
            g_keytable[SDLK_DOWN] = KC_DOWN;
            g_keytable[SDLK_RIGHT] = KC_RIGHT;
            g_keytable[SDLK_LEFT] = KC_LEFT;
            g_keytable[SDLK_INSERT] = KC_INSERT;
            g_keytable[SDLK_HOME] = KC_HOME;
            g_keytable[SDLK_END] = KC_END;
            g_keytable[SDLK_PAGEUP] = KC_PAGE_UP;
            g_keytable[SDLK_PAGEDOWN] = KC_PAGE_DOWN;
            g_keytable[SDLK_F1] = KC_F1;
            g_keytable[SDLK_F2] = KC_F2;
            g_keytable[SDLK_F3] = KC_F3;
            g_keytable[SDLK_F4] = KC_F4;
            g_keytable[SDLK_F5] = KC_F5;
            g_keytable[SDLK_F6] = KC_F6;
            g_keytable[SDLK_F7] = KC_F7;
            g_keytable[SDLK_F8] = KC_F8;
            g_keytable[SDLK_F9] = KC_F9;
            g_keytable[SDLK_F10] = KC_F10;
            g_keytable[SDLK_F11] = KC_F11;
            g_keytable[SDLK_F12] = KC_F12;
            g_keytable[SDLK_F13] = KC_F13;
            g_keytable[SDLK_F14] = KC_F14;
            g_keytable[SDLK_F15] = KC_F15;
            g_keytable[SDLK_NUMLOCKCLEAR] = KC_NUM_LOCK;
            g_keytable[SDLK_CAPSLOCK] = KC_CAPS_LOCK;
            g_keytable[SDLK_SCROLLLOCK] = KC_SCROLL_LOCK;
            g_keytable[SDLK_RSHIFT] = KC_RIGHT_SHIFT;
            g_keytable[SDLK_LSHIFT] = KC_LEFT_SHIFT;
            g_keytable[SDLK_RCTRL] = KC_RIGHT_CONTROL;
            g_keytable[SDLK_LCTRL] = KC_LEFT_CONTROL;
            g_keytable[SDLK_RALT] = KC_RIGHT_ALT;            
            g_keytable[SDLK_LALT] = KC_LEFT_ALT;
            g_keytable[SDLK_LGUI] = KC_LEFT_WINDOWS;
            g_keytable[SDLK_RGUI] = KC_RIGHT_WINDOWS;
            g_keytable[SDLK_MODE] = KC_MODE;
            g_keytable[SDLK_HELP] = KC_HELP;
            g_keytable[SDLK_PRINTSCREEN] = KC_PRINT_SCREEN;
            g_keytable[SDLK_SYSREQ] = KC_SYSREQ;
            g_keytable[SDLK_MENU] = KC_MENU;
            g_keytable[SDLK_POWER] = KC_POWER;
            g_keytable[SDLK_CURRENCYUNIT] = KC_EURO;
            g_keytable[SDLK_UNDO] = KC_UNDO;
        }

        int GetModifiers(unsigned int sdl_mod)
        {
            int result = 0;
            if (sdl_mod & KMOD_ALT) result += KM_ALT;
            if (sdl_mod & KMOD_CTRL) result += KM_CONTROL;
            if (sdl_mod & KMOD_SHIFT) result += KM_SHIFT;
            return result;
        }

        MouseButton MouseButtonFromSDL(int m, bool &error)
        {
            switch (m) {
            case SDL_BUTTON_LEFT: return MB_LEFT;
            case SDL_BUTTON_RIGHT: return MB_RIGHT;
            case SDL_BUTTON_MIDDLE: return MB_MIDDLE;
            default: error = true; return MB_LEFT;
            }
        }

        //
        // Handle SDL events.
        //

        void DoEvent(SDLWindow *focus_window, const SDL_Event &event)
        {
            switch (event.type) {
            case SDL_QUIT:
                if (focus_window) {
                    focus_window->forEachListener(OnClose());
                }
                break;

            case SDL_WINDOWEVENT:
                {
                    SDL_Window *sdl_window = SDL_GetWindowFromID(event.window.windowID);
                    if (sdl_window) {
                        SDLWindow *window = static_cast<SDLWindow*>(SDL_GetWindowData(sdl_window, "coercri"));
                        switch (event.window.event) {
                        case SDL_WINDOWEVENT_EXPOSED:
                            {
                                // Invalidate the entire screen (I don't think SDL
                                // gives more detailed info about the invalid
                                // rectangle?)
                                int w, h;
                                SDL_GetWindowSize(sdl_window, &w, &h);
                                Rectangle rectangle(0, 0, w, h);
                                window->invalidateRectangle(rectangle);
                            }
                            break;

                        case SDL_WINDOWEVENT_FOCUS_GAINED:
                            window->forEachListener(OnGainFocus());
                            break;

                        case SDL_WINDOWEVENT_FOCUS_LOST:
                            window->forEachListener(OnLoseFocus());
                            break;

                        case SDL_WINDOWEVENT_SHOWN:
                            window->forEachListener(OnUnminimize());
                            break;

                        case SDL_WINDOWEVENT_HIDDEN:
                            window->forEachListener(OnMinimize());
                            break;

                        case SDL_WINDOWEVENT_SIZE_CHANGED:
                            window->forEachListener(OnResize(event.window.data1, event.window.data2));
                            break;
                        }
                    }
                }
                break;

            case SDL_KEYDOWN:
            case SDL_KEYUP:
                {
                    // Find out what kind of key event this is.
                    const SDL_Keycode keysym = event.key.keysym.sym;
                    KeyEventType type;
                    if (event.type == SDL_KEYDOWN) {
                        if (event.key.repeat) {
                            type = KEY_AUTO_REPEAT;
                        } else {
                            type = KEY_PRESSED;
                        }
                    } else {
                        type = KEY_RELEASED;
                    }
                    
                    // Find the corresponding KeyCode.
                    KeyCode kc = KC_UNKNOWN;
                    std::map<SDL_Keycode, KeyCode>::const_iterator key_it = g_keytable.find(keysym);
                    if (key_it != g_keytable.end()) kc = key_it->second;

                    // Find the modifiers.
                    const int modifiers = GetModifiers(event.key.keysym.mod);
                    
                    // Send the key event, if required.
                    if (kc != KC_UNKNOWN && focus_window) {
                        focus_window->forEachListener(OnKey(type, kc, KeyModifier(modifiers)));
                    }
                }
                break;

            case SDL_TEXTINPUT:
                {
                    OnTextInput oti;
                    oti.str = UTF8String::fromUTF8Safe(event.text.text);
                    if (focus_window) focus_window->forEachListener(oti);
                }
                break;

            case SDL_MOUSEBUTTONDOWN:
                {
                    bool err = false;
                    const MouseButton mb = MouseButtonFromSDL(event.button.button, err);
                    if (!err && focus_window) {
                        focus_window->forEachListener(OnMouseDown(event.button.x, event.button.y, mb));
                    }
                }
                break;

            case SDL_MOUSEBUTTONUP:
                {
                    bool err = false;
                    const MouseButton mb = MouseButtonFromSDL(event.button.button, err);
                    if (!err && focus_window) {
                        focus_window->forEachListener(OnMouseUp(event.button.x, event.button.y, mb));
                    }
                }
                break;

            case SDL_MOUSEMOTION:
                if (focus_window) {
                    focus_window->forEachListener(OnMouseMove(event.motion.x, event.motion.y));
                }
                break;

            case SDL_MOUSEWHEEL:
                if (focus_window) {
                    int dy = event.wheel.y;
                    if (event.wheel.direction == SDL_MOUSEWHEEL_FLIPPED) {
                        dy = -dy;
                    }
                    const MouseButton mb = dy > 0 ? MB_WHEEL_DOWN : MB_WHEEL_UP;

                    // note: can't use event.wheel.mouseX/Y here,
                    // because not all linux distributions will have
                    // SDL 2.26 or later yet.
                    int x, y;
                    SDL_GetMouseState(&x, &y);

                    focus_window->forEachListener(OnMouseDown(x, y, mb));
                    focus_window->forEachListener(OnMouseUp(x, y, mb));
                }
                break;
            }
        }

        SDLWindow * FindCurrentWindow(const std::vector<boost::weak_ptr<SDLWindow> > & windows)
        {
            // Look for a window with current keyboard or mouse focus; we will send the
            // event to this window.
            // TODO: We should probably distinguish between keyboard and mouse events and
            // look for the appropriate focus type?
            SDL_Window * sdl_win = SDL_GetKeyboardFocus();
            if (!sdl_win) {
                sdl_win = SDL_GetMouseFocus();
            }

            if (sdl_win) {
                return static_cast<SDLWindow*>(SDL_GetWindowData(sdl_win, "coercri"));
            }

            // If no window currently has focus then just return the first valid window in
            // our list of windows, if possible.
            for (auto it = windows.begin(); it != windows.end(); ++it) {
                boost::shared_ptr<SDLWindow> win = it->lock();
                if (win) {
                    return win.get();
                }
            }

            // As a last resort, return null. (This will drop the event.)
            return nullptr;
        }

    } // namespace


    //
    // SDLGfxDriver implementation
    //
    
    SDLGfxDriver::SDLGfxDriver()
        : video_subsystem(SDL_INIT_VIDEO)
    {
        InitKeyTable();
    }

    boost::shared_ptr<Window> SDLGfxDriver::createWindow(int width, int height,
                                                         bool resizable, bool fullscreen,
                                                         const std::string &title)
    {
        if (fullscreen) {
            SDL_DisplayMode mode;
            int err = SDL_GetDesktopDisplayMode(0, &mode);
            if (err) {
                width = height = 600;
            } else {
                width = mode.w;
                height = mode.h;
            }
        }

        Uint32 flags = 0;
        if (fullscreen) flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;
        if (resizable) flags |= SDL_WINDOW_RESIZABLE;

        SDL_Window *sdl_window = SDL_CreateWindow(title.c_str(),
                                                  SDL_WINDOWPOS_UNDEFINED,
                                                  SDL_WINDOWPOS_UNDEFINED,
                                                  width,
                                                  height,
                                                  flags);

        if (sdl_window == NULL) {
            throw CoercriError("SDL_CreateWindow failed");
        }

        boost::shared_ptr<SDLWindow> result(new SDLWindow(sdl_window, width, height));
        windows.push_back(boost::weak_ptr<SDLWindow>(result));
        return result;
    }

    boost::shared_ptr<Graphic> SDLGfxDriver::createGraphic(boost::shared_ptr<const PixelArray> pixels, int hx, int hy)
    {
        return boost::shared_ptr<Graphic>(new SDLGraphic(pixels, hx, hy));
    }

    bool SDLGfxDriver::pollEvents()
    {
        // Remove expired weak ptrs from this->windows
        for (auto iter = windows.begin(); iter != windows.end(); ) {
            if (iter->expired()) {
                windows.erase(iter);
            } else {
                ++iter;
            }
        }

        // Check for windows that need resizing
        for (auto iter = windows.begin(); iter != windows.end(); ++iter) {
            boost::shared_ptr<SDLWindow> window = iter->lock();
            if (window && window->need_window_resize) {
                // process this first.
                int w,h;
                window->getSize(w,h);
                window->forEachListener(OnResize(w, h));
                window->need_window_resize = false;
                return true;
            }
        }

        // Check for an SDL event
        SDL_Event event;
        if (SDL_PollEvent(&event)) {

            SDLWindow *win = FindCurrentWindow(windows);

            DoEvent(win, event);
            return true;
        } else {
            return false;
        }
    }
}
