/*
 * FILE:
 *   lazy_bitmap_font.cpp
 *
 * AUTHOR:
 *   Stephen Thompson <stephen@solarflare.org.uk>
 *
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2025.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0,
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "lazy_bitmap_font.hpp"
#include "gfx_context.hpp"
#include "gfx_driver.hpp"
#include "glyph_creator.hpp"
#include "graphic.hpp"
#include "pixel_array.hpp"
#include "../core/utf8string.hpp"
#include "../external/utf8.h"


namespace Coercri {

    LazyBitmapFont::LazyBitmapFont(boost::shared_ptr<GfxDriver> driver,
                                   std::unique_ptr<GlyphCreator> creator,
                                   int atlas_w,
                                   int atlas_h)
        : gfx_driver(std::move(driver)),
          glyph_creator(std::move(creator)),
          atlas_width(atlas_w),
          atlas_height(atlas_h)
    {
    }

    void LazyBitmapFont::drawText(GfxContext &dest, int x, int y, const UTF8String &txt, Color col) const
    {
        const std::string &text = txt.asUTF8();

        char32_t previous = 0;

        utf8::iterator<std::string::const_iterator>
            begin(text.begin(), text.begin(), text.end()),
            end(text.end(), text.begin(), text.end()),
            it;

        for (it = begin; it != end; ++it) {
            char32_t codepoint = *it;

            // Apply kerning if available
            if (previous) {
                x += getKern(previous, codepoint);
            }

            const CachedGlyph &glyph = ensureGlyph(codepoint);

            if (glyph.has_pixels && !atlases.empty()) {
                dest.drawGraphicRegionModulated(
                    x + glyph.xofs,
                    y + glyph.yofs,
                    *atlases[glyph.atlas_index],
                    glyph.atlas_rect,
                    col);
            }

            x += glyph.xadvance;
            previous = codepoint;
        }
    }

    int LazyBitmapFont::getTextHeight() const
    {
        return glyph_creator->getLineHeight();
    }

    void LazyBitmapFont::getTextSize(const UTF8String &txt, int &w, int &h) const
    {
        const std::string &text = txt.asUTF8();

        utf8::iterator<std::string::const_iterator>
            begin(text.begin(), text.begin(), text.end()),
            end(text.end(), text.begin(), text.end()),
            it;

        w = 0;
        char32_t previous = 0;

        for (it = begin; it != end; ++it) {
            char32_t codepoint = *it;

            if (previous) {
                w += getKern(previous, codepoint);
            }

            const CachedGlyph &glyph = ensureGlyph(codepoint);
            w += glyph.xadvance;
            previous = codepoint;
        }

        h = glyph_creator->getLineHeight();
    }

    size_t LazyBitmapFont::getStringIndexAt(const UTF8String &txt, int x) const
    {
        const std::string &text = txt.asUTF8();

        utf8::iterator<std::string::const_iterator>
            begin(text.begin(), text.begin(), text.end()),
            end(text.end(), text.begin(), text.end()),
            it;

        int w = 0;
        char32_t previous = 0;

        for (it = begin; it != end; ++it) {

            if (w > x) {
                return it.base() - text.begin();
            }

            char32_t codepoint = *it;

            if (previous) {
                w += getKern(previous, codepoint);
            }

            const CachedGlyph &glyph = ensureGlyph(codepoint);
            w += glyph.xadvance;
            previous = codepoint;
        }

        return text.length();
    }

    const LazyBitmapFont::CachedGlyph& LazyBitmapFont::ensureGlyph(char32_t codepoint) const
    {
        auto it = glyph_cache.find(codepoint);
        if (it != glyph_cache.end()) {
            return it->second;
        }

        // Create the glyph
        GlyphData data = glyph_creator->createGlyph(codepoint);

        CachedGlyph glyph;
        glyph.xofs = data.xofs;
        glyph.yofs = data.yofs;
        glyph.xadvance = data.xadvance;
        glyph.has_pixels = !data.alpha.empty() && data.width > 0 && data.height > 0;

        if (glyph.has_pixels) {
            // Try to add to current atlas
            if (!addGlyphToAtlas(codepoint, glyph)) {
                // Current atlas is full, create a new one and try again
                createNewAtlas();
                if (!addGlyphToAtlas(codepoint, glyph)) {
                    // Glyph is too large for the atlas - treat as invisible
                    glyph.has_pixels = false;
                }
            }
        }

        auto result = glyph_cache.emplace(codepoint, glyph);
        return result.first->second;
    }

    bool LazyBitmapFont::addGlyphToAtlas(char32_t codepoint, CachedGlyph &glyph) const
    {
        // Get the glyph data again (we need the alpha values)
        GlyphData data = glyph_creator->createGlyph(codepoint);

        if (data.alpha.empty() || data.width <= 0 || data.height <= 0) {
            return true;  // Nothing to add
        }

        // Ensure we have an atlas
        if (atlases.empty()) {
            createNewAtlas();
        }

        // Check if glyph fits in current shelf
        if (current_x + data.width > atlas_width) {
            // Start a new shelf
            current_shelf_y += current_shelf_height;
            current_shelf_height = 0;
            current_x = 0;
        }

        // Check if we have room for a new shelf
        if (current_shelf_y + data.height > atlas_height) {
            return false;  // Atlas is full
        }

        // Place the glyph
        glyph.atlas_rect = Rectangle(current_x, current_shelf_y, data.width, data.height);
        glyph.atlas_index = static_cast<int>(atlases.size()) - 1;

        // Convert alpha data to RGBA PixelArray and upload to atlas
        PixelArray pixels(data.width, data.height);
        for (int y = 0; y < data.height; ++y) {
            for (int x = 0; x < data.width; ++x) {
                unsigned char a = data.alpha[y * data.width + x];
                pixels(x, y) = Color(255, 255, 255, a);
            }
        }

        atlases.back()->setPixels(current_x, current_shelf_y, pixels);

        // Update shelf packing state
        current_x += data.width;
        if (data.height > current_shelf_height) {
            current_shelf_height = data.height;
        }

        return true;
    }

    void LazyBitmapFont::createNewAtlas() const
    {
        // Create a new empty atlas with all pixels transparent
        PixelArray pixels(atlas_width, atlas_height);
        for (int y = 0; y < atlas_height; ++y) {
            for (int x = 0; x < atlas_width; ++x) {
                pixels(x, y) = Color(255, 255, 255, 0);
            }
        }

        atlases.push_back(gfx_driver->createGraphic(std::move(pixels), 0, 0, GraphicFlags::Dynamic));

        // Reset shelf packing state
        current_shelf_y = 0;
        current_shelf_height = 0;
        current_x = 0;
    }

    int LazyBitmapFont::getKern(char32_t left, char32_t right) const
    {
        uint64_t key = (static_cast<uint64_t>(left) << 32) | static_cast<uint64_t>(right);

        auto it = kern_cache.find(key);
        if (it != kern_cache.end()) {
            return it->second;
        }

        int kern = glyph_creator->getKern(left, right);
        kern_cache.emplace(key, kern);
        return kern;
    }

}
