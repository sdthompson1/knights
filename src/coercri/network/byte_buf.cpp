/*
 * FILE:
 *   byte_buf.cpp
 *
 * AUTHOR:
 *   Stephen Thompson
 *
 * CREATED:
 *   20-Mar-2009
 *
 * COPYRIGHT:
 *   Copyright (C) Stephen Thompson, 2008 - 2024.
 *
 *   This file is part of the "Coercri" software library. Usage of "Coercri"
 *   is permitted under the terms of the Boost Software License, Version 1.0, 
 *   the text of which is displayed below.
 *
 *   Boost Software License - Version 1.0 - August 17th, 2003
 *
 *   Permission is hereby granted, free of charge, to any person or organization
 *   obtaining a copy of the software and accompanying documentation covered by
 *   this license (the "Software") to use, reproduce, display, distribute,
 *   execute, and transmit the Software, and to prepare derivative works of the
 *   Software, and to permit third-parties to whom the Software is furnished to
 *   do so, all subject to the following:
 *
 *   The copyright notices in the Software and this entire statement, including
 *   the above license grant, this restriction and the following disclaimer,
 *   must be included in all copies of the Software, in whole or in part, and
 *   all derivative works of the Software, unless such copies or derivative
 *   works are solely in the form of machine-executable object code generated by
 *   a source language processor.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

#include "byte_buf.hpp"

#include "../core/coercri_error.hpp"

#include <algorithm>
#include <cstddef>

namespace Coercri {

    int InputByteBuf::readUbyte()
    {
        if (eof()) {
            throw CoercriError("readUbyte failed");
        } else {
            return *iter++;
        }
    }
    
    int InputByteBuf::readByte()
    {
        const int x = readUbyte();
        if (x < 128) {
            return x;
        } else {
            return x - 256;
        }
    }
    
    int InputByteBuf::readUshort()
    {
        const int high = readUbyte();
        const int low = readUbyte();
        return (high * 256) + low;
    }
    
    int InputByteBuf::readShort()
    {
        const int high = readByte();
        const int low = readUbyte();
        return (high * 256) + low;
    }
    
    int InputByteBuf::readVarInt()
    {
        unsigned int val;
        bool sign;
        int c = readUbyte();
        // bit 7 = extend bit
        // bit 6 = sign bit
        // bits 5-0 = least significant bits
        val = (c & 0x3f);
        sign = (c & 0x40) != 0;
        if (c & 0x80) {
            // 2nd byte
            c = readUbyte();
            val |= ((c & 0x7f) << 6);
            if (c & 0x80) {
                // 3rd byte
                c = readUbyte();
                val |= ((c & 0x7f) << 13);
                if (c & 0x80) {
                    // 4th byte
                    c = readUbyte();
                    val |= (c << 20);
                } 
            }
        }
        if (sign) {
            return -int(val) - 1;
        } else {
            return val;
        }
    }

    void InputByteBuf::readNibbles(int &x, int &y)
    {
        int ub = readUbyte();
        x = (ub >> 4);
        y = (ub & 15);
    }
    
    std::string InputByteBuf::readString()
    {
        std::string s;
        const std::ptrdiff_t size = readVarInt();
        if (size < 0) throw CoercriError("readString: invalid length");
        s.resize(std::min(size, buf.end() - iter));
        for (std::string::iterator it = s.begin(); it != s.end(); ++it) {
            *it = static_cast<char>(readUbyte());
        }
        return s;
    }


    void OutputByteBuf::writeUbyte(int x)
    {
        if (x < 0 || x > 255) throw CoercriError("writeUbyte: out of range");
        buf->push_back(x);
    }
    
    void OutputByteBuf::writeUshort(int x)
    {
        if (x < 0 || x > 65535) {
            throw CoercriError("writeUshort: out of range");
        }
        buf->push_back(x >> 8);
        buf->push_back(x & 0xff);
    }

    void OutputByteBuf::writeShort(int x)
    {
        if (x < -32768 || x > 32767) throw CoercriError("writeShort: out of range");
        writeUshort(x & 0xffff);
    }

    void OutputByteBuf::writeVarInt(int x)
    {
        if (x < -268435456 || x > 268435455) throw CoercriError("writeVarInt: out of range");
        
        unsigned int sign;
        unsigned int val;
        if (x >= 0) {
            val = x;
            sign = 0;
        } else {
            val = -x-1;
            sign = 0x40;
        }
        
        if (val <= 63) {
            writeUbyte(sign + val);
        } else {
            writeUbyte(0x80 + sign + (val & 0x3f));
            if (val <= 8191) {
                writeUbyte(val >> 6);
            } else {
                writeUbyte(0x80 + ((val >> 6) & 0x7f));
                if (val <= 1048575) {
                    writeUbyte(val >> 13);
                } else {
                    writeUbyte(0x80 + ((val >> 13) & 0x7f));
                    writeUbyte(val >> 20);
                }
            }
        }
    }
    
    void OutputByteBuf::writeNibbles(int x, int y)
    {
        if (x < 0 || x > 15 || y < 0 || y > 15) throw CoercriError("writeNibbles: value out of range");
        writeUbyte((x << 4) + y);
    }
    
    void OutputByteBuf::writeString(const std::string &x)
    {
        writeVarInt(x.size());
        for (std::string::const_iterator it = x.begin(); it != x.end(); ++it) {
            writeUbyte(static_cast<unsigned char>(*it));
        }
    }

    void OutputByteBuf::writePayloadSize(size_t &pos)
    {
        pos = buf->size();
        writeUshort(0);
    }

    void OutputByteBuf::backpatchPayloadSize(size_t pos)
    {
        size_t payload_size = buf->size() - pos - 2;
        (*buf)[pos] = payload_size >> 8;
        (*buf)[pos+1] = payload_size & 0xff;
    }
}
