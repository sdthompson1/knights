# -*- fundamental -*-

#
# This file is part of Knights.
#
# Copyright (C) Stephen Thompson, 2006 - 2012.
# Copyright (C) Kalle Marjola, 1994.
#
# Knights is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Knights is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Knights.  If not, see <http://www.gnu.org/licenses/>.
#

include "fixup.txt"

include "graphics.txt"

# Depths:
# -4 = open pits, treasure chests, doors.   (We don't want blood etc appearing on top of these)
# -3 = blood
# -2 = vampire bat corpses.
# -1 = knight corpses; zombie corpses; bones
# 0 = default tile depth.
# NB RemoteDungeonView currently assumes that depths are between -8 and +7, although that
# could be changed of course.


# Tiles can require up to 8 axe hits (32 sword hits)
# but make the larger amounts progressively less likely.

tile_hit_points = Random(d15+1, d23+1, d31+1)


locked_msg = FlashMessage("Locked", 2)

# Define some access types

wall_acc = {
    walking = "blocked"
    flying = "blocked"
    missiles = "blocked"
}
door_acc = {
    walking = "approach"
    flying = "approach"
    missiles = "blocked"
}
gate_acc = {
    walking = "approach"
    flying = "approach"
    missiles = "partial"
}
switch_acc = {
    walking = "approach"
    flying = "clear"
    missiles = "partial"
}
barrel_acc = {
    walking = "blocked"
    flying = "clear"
    missiles = "clear"
}
furniture_acc = {
    walking = "approach"
    flying = "clear"
    missiles = "clear"
}
floor_acc = {
    walking = "clear"
    flying = "clear"
    missiles = "clear"
}


# Numbers in the following are the original numbering from Knights.
# Note the following number ranges are unused in Knights:
# <=1, 20-22, 29-31, 33-34, 46, >=86.


# Walls and pillars.

wall = {
    access = wall_acc
}

t_wall_normal = wall & { graphic=g_wall }          # 2
t_wall_pillar = wall & { graphic=g_pillar, user_table = 1 }        # 3
t_wall_skull_east = wall & { graphic=g_skull_right, reflect=t_wall_skull_west, rotate=t_wall_skull_south }   # 4
t_wall_skull_west = wall & { graphic=g_skull_left,  reflect=t_wall_skull_east, rotate=t_wall_skull_north }   # 5
t_wall_skull_north = wall & { graphic = g_skull_up,   rotate=t_wall_skull_east }
t_wall_skull_south = wall & { graphic = g_skull_down, rotate=t_wall_skull_west }
t_wall_cage  = wall & { graphic=g_cage }         # 6


# Doors.
# Those funny letters in door names mean the following:
# 1. 'h' = horizontal or 'v' = vertical
# 2. 'w' = wooden, 'i' = iron, 'g' = gate (portcullis).
# 3. 'c' = closed, 'o' = open.

door_control = {
    action = Activate()
    menu_icon = g_menu_open_close
    menu_direction = "up"
    tap_priority = 4
    action_bar_slot = 2
    menu_special = 1
    name = "Open/Close Door"
}

chest_control = door_control & { name = "Open/Close Chest" }

# door_control_low_pri is used for open doors, because we want pickup/drop to take priority over
# closing a door (but we want opening a door to take priority over pickup/drop).
door_control_low_pri = door_control & { tap_priority = 1 }
chest_control_low_pri = chest_control & { tap_priority = 1 }

door_control_lua_func = "if kts.is_door_open(...) then return door_control_low_pri; else return door_control; end"
chest_control_lua_func = "if kts.is_door_open(...) then return chest_control_low_pri; else return chest_control; end"

door_base = {
    type     = "door"
    access   = door_acc
#    on_activate  = [OnSuccess([],
#                              [locked_msg, snd_lock] 
#                             )]
    on_open_or_close  = snd_door
    control = door_control_lua_func
}
wood_door = door_base & {
    hit_points  = tile_hit_points
    on_hit      = snd_tile_bash
    on_destroy  = [AddTile(t_broken_wood_1), snd_tile_destroy]
    lock_chance = 10
    keymax      = 3
    tutorial = TUT_DOOR
}
iron_door = door_base & {
    lock_chance = 100
    keymax      = 3
    on_hit      = snd_tile_clunk
    tutorial    = TUT_IRON_DOOR
}
gate = {
    access      = gate_acc
    on_hit      = snd_tile_clunk
    tutorial    = TUT_PORTCULLIS
    user_table  = 1
}

t_door_horiz      = wood_door & { depth=-4, graphic=g_door_hwc, open_graphic=g_door_hwo, rotate=t_door_vert }     # 7, 50
t_door_vert       = wood_door & { depth=-4, graphic=g_door_vwc, open_graphic=g_door_vwo, rotate=t_door_horiz }    # 8, 51
t_iron_door_horiz = iron_door & { depth=-4, graphic=g_door_hic, open_graphic=g_door_hio, rotate=t_iron_door_vert }     # 9, 52
t_iron_door_vert  = iron_door & { depth=-4, graphic=g_door_vic, open_graphic=g_door_vio, rotate=t_iron_door_horiz }    # 10, 53


# NOTE: For closed gates set connectivity_check = -1 to force the connectivity check
# to consider these as "impassable". (They may or may not be openable by a switch, but 
# we don't really have any way to check this so we have to be conservative and assume
# they can't be.)

t_gate_horiz      = gate & { depth=-4, graphic=g_door_hgc, connectivity_check = -1, rotate=t_gate_vert }     # 16, 64
t_gate_vert       = gate & { depth=-4, graphic=g_door_vgc, connectivity_check = -1, rotate=t_gate_horiz }    # 17, 65
t_open_gate_horiz = floor & { graphic=g_door_hgo, user_table = 1, rotate=t_open_gate_vert }
t_open_gate_vert  = floor & { graphic=g_door_vgo, user_table = 1, rotate=t_open_gate_horiz }

t_door_horiz_locked = t_door_horiz & { special_lock=1, editor_label="L", rotate=t_door_vert_locked }
t_door_vert_locked = t_door_vert & { special_lock=1, editor_label="L", rotate=t_door_horiz_locked }
t_iron_door_horiz_locked = t_iron_door_horiz & { special_lock = 1, editor_label="L", rotate=t_iron_door_vert_locked }
t_iron_door_vert_locked = t_iron_door_vert & { special_lock = 1, editor_label="L", rotate=t_iron_door_horiz_locked }

t_hdoor_background = floor & { graphic = g_hdoor_background, rotate=t_vdoor_background }
t_vdoor_background = floor & { graphic = g_vdoor_background, rotate=t_hdoor_background }

# Homes. (Facing is the direction TOWARDS the dungeon -- AWAY from the home itself.)

home = {
    access = door_acc
    type = "home"
    unsecured_colour = 0
    on_hit = snd_tile_clunk
    tutorial = TUT_HOME
}

t_home_south  = home & { graphic=g_home_south, facing="south", rotate=t_home_west }     # 11
t_home_west   = home & { graphic=g_home_west,  facing="west", rotate=t_home_north, reflect=t_home_east }      # 12
t_home_north  = home & { graphic=g_home_north, facing="north", rotate=t_home_east }     # 13
t_home_east   = home & { graphic=g_home_east,  facing="east", rotate=t_home_south, reflect=t_home_west }      # 14

t_home_south_special = t_home_south & { special_exit = 1, editor_label = "X", rotate = t_home_west_special }  # 92
t_home_west_special  = t_home_west  & { special_exit = 1, editor_label = "X", rotate = t_home_north_special } # 93
t_home_north_special = t_home_north & { special_exit = 1, editor_label = "X", rotate = t_home_east_special }  # 94
t_home_east_special  = t_home_east  & { special_exit = 1, editor_label = "X", rotate = t_home_south_special } # 95


# Crystal balls.

t_crystal_ball = {           # 15
    access = door_acc
    graphic = g_crystal_ball 
    on_approach  = CrystalStart()
    on_withdraw  = CrystalStop()
    on_hit = snd_tile_clunk
    tutorial = TUT_CRYSTAL_BALL
    user_table = 1
}


# Switches

switch = {
    access = switch_acc
    on_hit = [Activate(), snd_tile_bash]
    control = door_control & { name = "Pull Lever" }
    items = 0
    tutorial = TUT_SWITCH
}
t_switch_up =   switch & {     # 18
    graphic = g_switch_up, 
    on_activate = [ChangeTile(t_switch_down), snd_door]
}
t_switch_down = switch & {     # 19
    graphic = g_switch_down, 
    on_activate = [ChangeTile(t_switch_up),   snd_door]
}



# Various bits of furniture.

furniture = {
    access     = furniture_acc
    hit_points = tile_hit_points
    on_hit = snd_tile_bash
}

furniture4 = furniture & { on_destroy = [AddTile(t_broken_wood_4), snd_tile_destroy] }
furniture5 = furniture & { on_destroy = [AddTile(t_broken_wood_5), snd_tile_destroy] }

t_haystack = furniture4 & {   # 23
    access  = switch_acc
    graphic = g_haystack 
}
t_barrel = furniture4 & {   # 24
    type = "barrel"
    access = barrel_acc
    graphic = g_barrel 
    items = "barrel"
    # Note we don't have to explicitly say "items are not allowed" -- indeed this would not
    # be possible in the current system (since setting "items" to an item generation
    # category sets items-allowed to true as well) -- but setting the tile-type to "barrel" 
    # automatically sets items-allowed to false (as a special case) -- see special_tiles.cpp.
}

chest = {
    type        = "chest"
    items       = "chest"
    access      = furniture_acc
    trap_chance = 50   # This only applies if pretrapped chests is on
    # NB the way the following line is set up is not ideal (we're duplicating the trap setup from items.txt)
    # -- indeed the whole code for pretrapped chests is a bit of an ugly hack at the moment...
    traps = [[i_poison_trap,SetPoisonTrap()], [i_blade_trap,SetBladeTrap(i_bolts)]]
    lock_chance = 50   # This only applies if a trap was not generated.
    lock_pick_only_chance = 17   # Chance (in %) that the lock cannot be opened by any key, and requires lock picks.
    keymax      = 3              # If nkeys < this then there is more chance the chest will be unlocked.
    hit_points  = tile_hit_points
    on_destroy  = [AddTile(t_broken_wood_3), snd_tile_destroy]
    control = chest_control_lua_func
#    on_activate = [OnSuccess([],
#                             [locked_msg, snd_lock] 
#                            )]
    on_open_or_close = snd_door
    on_hit      = snd_tile_bash
    depth       = -4
    tutorial = TUT_CHEST
}

t_chest_north = chest & { graphic=g_chest_north, 
    open_graphic=g_open_chest_north, facing="north", rotate=t_chest_east } # 25, 35
t_chest_east  = chest & { graphic=g_chest_east,  
    open_graphic=g_open_chest_east,  facing="east", rotate=t_chest_south, reflect=t_chest_west }  # 26, 36
t_chest_south = chest & { graphic=g_chest_south, 
    open_graphic=g_open_chest_south, facing="south", rotate=t_chest_west } # 27, 37
t_chest_west  = chest & { graphic=g_chest_west,  
    open_graphic=g_open_chest_west,  facing="west", rotate=t_chest_north, reflect=t_chest_east }  # 28, 38

t_small_skull = {    # 32
    access = furniture_acc
    items = "small_table"
    graphic = g_small_skull
    on_hit = snd_tile_clunk
}

table_base = {
    access = furniture_acc
    hit_points = tile_hit_points
    items = "table"
    on_hit = snd_tile_bash
}
table4 = table_base & { on_destroy = [AddTile(t_broken_wood_4), snd_tile_destroy] }
table5 = table_base & { on_destroy = [AddTile(t_broken_wood_5), snd_tile_destroy] }

t_table_small = table5 &     { graphic=g_table_small, items="small_table" }  # 39
t_table_north = table5 &     { graphic=g_table_north, rotate=t_table_east }  # 40
t_table_vert  = table5 &     { graphic=g_table_vert,  rotate=t_table_horiz }   # 41
t_table_south = table5 &     { graphic=g_table_south, rotate=t_table_west }  # 42
t_table_west  = table5 &     { graphic=g_table_west,  rotate=t_table_north, reflect=t_table_east }
t_table_horiz = table5 &     { graphic=g_table_horiz, rotate=t_table_vert }
t_table_east  = table5 &     { graphic=g_table_east,  rotate=t_table_south, reflect=t_table_west }

t_large_table_horiz = table4 & { graphic=g_large_table_horiz, rotate=t_large_table_vert }  # 43
t_large_table_vert  = table4 & { graphic=g_large_table_vert,  rotate=t_large_table_horiz }

t_chair_south = furniture4 & { graphic=g_chair_south, rotate=t_chair_west }  # 44
t_chair_north = furniture4 & { graphic=g_chair_north, rotate=t_chair_east }  # 45
t_chair_west  = furniture4 & { graphic=g_chair_west,  rotate=t_chair_north, reflect=t_chair_east }
t_chair_east  = furniture4 & { graphic=g_chair_east,  rotate=t_chair_south, reflect=t_chair_west }


# Pits.

closed_pit = floor & { user_table = 1 }

open_pit = 
    {
        access       = floor_acc
        on_walk_over = PitKill()
        items        = 'destroy'
        
        # Even though a pit has "clear" access (at all heights) it should still block the 
        # connectivity check. (Actually some open pits are passable, because they can be 
        # closed by switches, but we can't easily check this, so we err on the side of 
        # caution and mark it "impassable" always.)
        connectivity_check = -1

        tutorial = TUT_PIT
        user_table = 1
    }

t_open_pit_vert   = open_pit & {     # 47
    graphic = g_pitv_o
    depth   = -4
    rotate  = t_open_pit_horiz
}

t_open_pit_horiz = open_pit & {
    graphic = g_pith_o
    depth   = -4
    rotate  = t_open_pit_vert
}

t_open_pit_wooden = open_pit & {     # 48
    graphic = g_wooden_pit
    depth   = -4
}
t_open_pit_normal = open_pit & {     # 49
    graphic = g_pit_o
    depth   = -4
}

t_closed_pit_vert = closed_pit & {   # 78
    graphic = g_pitv_c
    rotate = t_closed_pit_horiz
}

t_closed_pit_horiz = closed_pit & {
    graphic = g_pith_c
    rotate = t_closed_pit_vert
}

t_closed_pit_wooden = closed_pit & { # 79
    graphic = g_wooden_floor
}
t_closed_pit_normal = closed_pit & { # 80
    graphic = g_pit_c
}


# This is a list of all "open pit" tiles, used in monsters.txt
all_open_pit_tiles = [t_open_pit_horiz, t_open_pit_vert, t_open_pit_wooden, t_open_pit_normal]


# Floor tiles of all kinds.

floor = {
    access = floor_acc
    items  = "floor"
}

t_broken_wood_1 = floor & { graphic=g_broken_wood_1 }  # 54
t_broken_wood_2 = floor & { graphic=g_broken_wood_2 }  # 55
t_broken_wood_3 = floor & { graphic=g_broken_wood_3 }  # 56
t_broken_wood_4 = floor & { graphic=g_broken_wood_4 }  # 57
t_broken_wood_5 = floor & { graphic=g_broken_wood_5 }  # 58

t_floor1  = floor & { graphic=g_floor1 }  # 66
t_floorpp = floor & { graphic=g_pressure_plate }  # 67
t_floor2  = floor & { graphic=g_floor2 }  # 68
t_floor3  = floor & { graphic=g_floor3 }  # 69
t_floor4  = floor & { graphic=g_floor4 }  # 70
t_floor5  = floor & { graphic=g_floor5 }  # 71
t_floor6  = floor & { graphic=g_floor6, depth=-1 }  # 72
t_floor7  = floor & { graphic=g_floor7 }  # 73
t_floor8  = floor & { graphic=g_floor8 }  # 74
t_floor9  = floor & { graphic=g_floor9 }  # 75
t_floor10 = floor & { graphic=g_floor10 }  # 77

t_dead_pentagram = floor & {   # 76
    graphic      = g_pentagram  
    tutorial = TUT_PENTAGRAM
    user_table = 1
}
t_live_pentagram = floor & {   # 1 in my room tables. (76 in Knights.)
    graphic      = g_pentagram
##    on_walk_over = IfKnight([zap, pentagram_effect])  # zombies can walk over pentagrams with impunity, but knights get zapped.
## TODO need to re-enable pentagram. (move effect from items.lua to here!!)
    editor_label = "P"
    tutorial = TUT_PENTAGRAM
    user_table = 1
}
t_special_pentagram = t_live_pentagram & {  # 90
    on_hit = CheckQuest()
    editor_label = "S"
}


# Stairs

t_stairs_top   = floor & { graphic=g_stairs_top, stairs_down="special" }   # 81
t_stairs_south = floor & { graphic=g_stairs_south, stairs_down="south", rotate=t_stairs_west } # 82  
t_stairs_west  = floor & { graphic=g_stairs_west,  stairs_down="west", rotate=t_stairs_north, reflect=t_stairs_east }  # 83
t_stairs_north = floor & { graphic=g_stairs_north, stairs_down="north", rotate=t_stairs_east }  # 84
t_stairs_east  = floor & { graphic=g_stairs_east,  stairs_down="east", rotate=t_stairs_south, reflect=t_stairs_west }  # 85


#############

t_blood_1 = floor & {graphic=g_blood_1, depth=-3}
t_blood_2 = floor & {graphic=g_blood_2, depth=-3}
t_blood_3 = floor & {graphic=g_blood_3, depth=-3}

t_dead_knight_1 = floor & { graphic = g_dead_knight_1, depth = -1 } 
t_dead_knight_2 = floor & { graphic = g_dead_knight_2, depth = -1 } 
t_dead_knight_3 = floor & { graphic = g_dead_knight_3, depth = -1 } 
t_dead_knight_4 = floor & { graphic = g_dead_knight_4, depth = -1 } 

t_dead_zombie = floor & { graphic=g_dead_zombie, depth = -1 }    # 59

t_dead_vbat_1 = floor & { graphic = g_dead_vbat_1, depth = -2 }
t_dead_vbat_2 = floor & { graphic = g_dead_vbat_2, depth = -2 }
t_dead_vbat_3 = floor & { graphic = g_dead_vbat_3, depth = -2 }

#############
